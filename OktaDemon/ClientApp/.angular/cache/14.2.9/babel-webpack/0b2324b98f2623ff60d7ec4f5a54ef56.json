{"ast":null,"code":"import _asyncToGenerator from \"C:/Users/Narean/source/repos/OktaDemon/OktaDemon/ClientApp/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\n\n/*!\n * Copyright (c) 2015-present, Okta, Inc. and/or its affiliates. All rights reserved.\n * The Okta software accompanied by this notice is provided pursuant to the Apache License, Version 2.0 (the \"License.\")\n *\n * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0.\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * \n * See the License for the specific language governing permissions and limitations under the License.\n */\nimport { interact } from './interact.js';\nimport { introspect } from './introspect.js';\nimport { remediate } from './remediate.js';\nimport { IdxStatus } from './types/api.js';\nimport './remediators/EnrollAuthenticator.js';\nimport './remediators/EnrollPoll.js';\nimport './remediators/SelectEnrollmentChannel.js';\nimport './remediators/EnrollmentChannelData.js';\nimport './remediators/ChallengeAuthenticator.js';\nimport './remediators/ChallengePoll.js';\nimport './remediators/ResetAuthenticator.js';\nimport './remediators/EnrollProfile.js';\nimport './remediators/Identify.js';\nimport './remediators/ReEnrollAuthenticator.js';\nimport './remediators/RedirectIdp.js';\nimport './remediators/SelectAuthenticatorAuthenticate.js';\nimport './remediators/SelectAuthenticatorEnroll.js';\nimport './remediators/SelectAuthenticatorUnlockAccount.js';\nimport './remediators/SelectEnrollProfile.js';\nimport './remediators/AuthenticatorVerificationData.js';\nimport './remediators/AuthenticatorEnrollmentData.js';\nimport './remediators/Skip.js';\nimport { getFlowSpecification } from './flow/FlowSpecification.js';\nimport { saveTransactionMeta, getSavedTransactionMeta } from './transactionMeta.js';\nimport { getEnabledFeatures, getAvailableSteps, getMessagesFromResponse, isTerminalResponse } from './util.js';\n\nfunction initializeValues(options) {\n  const knownOptions = ['flow', 'remediators', 'actions', 'withCredentials', 'step', 'useGenericRemediator', 'exchangeCodeForTokens'];\n  const values = Object.assign({}, options);\n  knownOptions.forEach(option => {\n    delete values[option];\n  });\n  return values;\n}\n\nfunction initializeData(authClient, data) {\n  let {\n    options\n  } = data;\n  options = Object.assign(Object.assign({}, authClient.options.idx), options);\n  let {\n    flow,\n    withCredentials,\n    remediators,\n    actions\n  } = options;\n  const status = IdxStatus.PENDING;\n  flow = flow || authClient.idx.getFlow() || 'default';\n\n  if (flow) {\n    authClient.idx.setFlow(flow);\n    const flowSpec = getFlowSpecification(authClient, flow);\n    withCredentials = typeof withCredentials !== 'undefined' ? withCredentials : flowSpec.withCredentials;\n    remediators = remediators || flowSpec.remediators;\n    actions = actions || flowSpec.actions;\n  }\n\n  return Object.assign(Object.assign({}, data), {\n    options: Object.assign(Object.assign({}, options), {\n      flow,\n      withCredentials,\n      remediators,\n      actions\n    }),\n    status\n  });\n}\n\nfunction getDataFromIntrospect(_x, _x2) {\n  return _getDataFromIntrospect.apply(this, arguments);\n}\n\nfunction _getDataFromIntrospect() {\n  _getDataFromIntrospect = _asyncToGenerator(function* (authClient, data) {\n    const {\n      options\n    } = data;\n    const {\n      stateHandle,\n      withCredentials,\n      version,\n      state,\n      scopes,\n      recoveryToken,\n      activationToken,\n      maxAge,\n      nonce\n    } = options;\n    let idxResponse;\n    let meta = getSavedTransactionMeta(authClient, {\n      state,\n      recoveryToken,\n      activationToken\n    });\n\n    if (stateHandle) {\n      idxResponse = yield introspect(authClient, {\n        withCredentials,\n        version,\n        stateHandle\n      });\n    } else {\n      let interactionHandle = meta === null || meta === void 0 ? void 0 : meta.interactionHandle;\n\n      if (!interactionHandle) {\n        authClient.transactionManager.clear();\n        const interactResponse = yield interact(authClient, {\n          withCredentials,\n          state,\n          scopes,\n          activationToken,\n          recoveryToken,\n          maxAge,\n          nonce\n        });\n        interactionHandle = interactResponse.interactionHandle;\n        meta = interactResponse.meta;\n      }\n\n      idxResponse = yield introspect(authClient, {\n        withCredentials,\n        version,\n        interactionHandle\n      });\n    }\n\n    return Object.assign(Object.assign({}, data), {\n      idxResponse,\n      meta\n    });\n  });\n  return _getDataFromIntrospect.apply(this, arguments);\n}\n\nfunction getDataFromRemediate(_x3, _x4) {\n  return _getDataFromRemediate.apply(this, arguments);\n}\n\nfunction _getDataFromRemediate() {\n  _getDataFromRemediate = _asyncToGenerator(function* (authClient, data) {\n    let {\n      idxResponse,\n      options,\n      values\n    } = data;\n    const {\n      autoRemediate,\n      remediators,\n      actions,\n      flow,\n      step,\n      useGenericRemediator\n    } = options;\n    const shouldRemediate = autoRemediate !== false && (remediators || actions || step);\n\n    if (!shouldRemediate) {\n      return data;\n    }\n\n    values = Object.assign(Object.assign({}, values), {\n      stateHandle: idxResponse.rawIdxState.stateHandle\n    });\n    const {\n      idxResponse: idxResponseFromRemediation,\n      nextStep,\n      canceled\n    } = yield remediate(authClient, idxResponse, values, {\n      remediators,\n      actions,\n      flow,\n      step,\n      useGenericRemediator\n    });\n    idxResponse = idxResponseFromRemediation;\n    return Object.assign(Object.assign({}, data), {\n      idxResponse,\n      nextStep,\n      canceled\n    });\n  });\n  return _getDataFromRemediate.apply(this, arguments);\n}\n\nfunction getTokens(_x5, _x6) {\n  return _getTokens.apply(this, arguments);\n}\n\nfunction _getTokens() {\n  _getTokens = _asyncToGenerator(function* (authClient, data) {\n    let {\n      meta,\n      idxResponse\n    } = data;\n    const {\n      interactionCode\n    } = idxResponse;\n    const {\n      clientId,\n      codeVerifier,\n      ignoreSignature,\n      redirectUri,\n      urls,\n      scopes\n    } = meta;\n    const tokenResponse = yield authClient.token.exchangeCodeForTokens({\n      interactionCode,\n      clientId,\n      codeVerifier,\n      ignoreSignature,\n      redirectUri,\n      scopes\n    }, urls);\n    return tokenResponse.tokens;\n  });\n  return _getTokens.apply(this, arguments);\n}\n\nfunction finalizeData(_x7, _x8) {\n  return _finalizeData.apply(this, arguments);\n}\n\nfunction _finalizeData() {\n  _finalizeData = _asyncToGenerator(function* (authClient, data) {\n    let {\n      options,\n      idxResponse,\n      canceled,\n      status\n    } = data;\n    const {\n      exchangeCodeForTokens\n    } = options;\n    let shouldSaveResponse = false;\n    let shouldClearTransaction = false;\n    let clearSharedStorage = true;\n    let interactionCode;\n    let tokens;\n    let enabledFeatures;\n    let availableSteps;\n    let messages;\n    let terminal;\n\n    if (idxResponse) {\n      shouldSaveResponse = !!(idxResponse.requestDidSucceed || idxResponse.stepUp);\n      enabledFeatures = getEnabledFeatures(idxResponse);\n      availableSteps = getAvailableSteps(authClient, idxResponse, options.useGenericRemediator);\n      messages = getMessagesFromResponse(idxResponse, options);\n      terminal = isTerminalResponse(idxResponse);\n    }\n\n    if (terminal) {\n      status = IdxStatus.TERMINAL;\n      const hasActions = Object.keys(idxResponse.actions).length > 0;\n      const hasErrors = !!messages.find(msg => msg.class === 'ERROR');\n      const isTerminalSuccess = !hasActions && !hasErrors && idxResponse.requestDidSucceed === true;\n\n      if (isTerminalSuccess) {\n        shouldClearTransaction = true;\n      } else {\n        shouldSaveResponse = !!hasActions;\n      }\n\n      clearSharedStorage = false;\n    } else if (canceled) {\n      status = IdxStatus.CANCELED;\n      shouldClearTransaction = true;\n    } else if (idxResponse === null || idxResponse === void 0 ? void 0 : idxResponse.interactionCode) {\n      interactionCode = idxResponse.interactionCode;\n\n      if (exchangeCodeForTokens === false) {\n        status = IdxStatus.SUCCESS;\n        shouldClearTransaction = false;\n      } else {\n        tokens = yield getTokens(authClient, data);\n        status = IdxStatus.SUCCESS;\n        shouldClearTransaction = true;\n      }\n    }\n\n    return Object.assign(Object.assign({}, data), {\n      status,\n      interactionCode,\n      tokens,\n      shouldSaveResponse,\n      shouldClearTransaction,\n      clearSharedStorage,\n      enabledFeatures,\n      availableSteps,\n      messages,\n      terminal\n    });\n  });\n  return _finalizeData.apply(this, arguments);\n}\n\nfunction run(_x9) {\n  return _run.apply(this, arguments);\n}\n\nfunction _run() {\n  _run = _asyncToGenerator(function* (authClient, options = {}) {\n    var _a;\n\n    let data = {\n      options,\n      values: initializeValues(options)\n    };\n    data = initializeData(authClient, data);\n    data = yield getDataFromIntrospect(authClient, data);\n    data = yield getDataFromRemediate(authClient, data);\n    data = yield finalizeData(authClient, data);\n    const {\n      idxResponse,\n      meta,\n      shouldSaveResponse,\n      shouldClearTransaction,\n      clearSharedStorage,\n      status,\n      enabledFeatures,\n      availableSteps,\n      tokens,\n      nextStep,\n      messages,\n      error,\n      interactionCode\n    } = data;\n\n    if (shouldClearTransaction) {\n      authClient.transactionManager.clear({\n        clearSharedStorage\n      });\n    } else {\n      saveTransactionMeta(authClient, Object.assign({}, meta));\n\n      if (shouldSaveResponse) {\n        const {\n          rawIdxState: rawIdxResponse,\n          requestDidSucceed\n        } = idxResponse;\n        authClient.transactionManager.saveIdxResponse({\n          rawIdxResponse,\n          requestDidSucceed,\n          stateHandle: (_a = idxResponse.context) === null || _a === void 0 ? void 0 : _a.stateHandle,\n          interactionHandle: meta === null || meta === void 0 ? void 0 : meta.interactionHandle\n        });\n      }\n    }\n\n    const {\n      actions,\n      context,\n      neededToProceed,\n      proceed,\n      rawIdxState,\n      requestDidSucceed,\n      stepUp\n    } = idxResponse || {};\n    return Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({\n      status: status\n    }, meta && {\n      meta\n    }), enabledFeatures && {\n      enabledFeatures\n    }), availableSteps && {\n      availableSteps\n    }), tokens && {\n      tokens\n    }), nextStep && {\n      nextStep\n    }), messages && messages.length && {\n      messages\n    }), error && {\n      error\n    }), stepUp && {\n      stepUp\n    }), {\n      interactionCode,\n      actions: actions,\n      context: context,\n      neededToProceed: neededToProceed,\n      proceed: proceed,\n      rawIdxState: rawIdxState,\n      requestDidSucceed\n    });\n  });\n  return _run.apply(this, arguments);\n}\n\nexport { run }; //# sourceMappingURL=run.js.map","map":null,"metadata":{},"sourceType":"module"}