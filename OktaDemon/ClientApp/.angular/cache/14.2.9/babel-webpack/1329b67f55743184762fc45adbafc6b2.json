{"ast":null,"code":"/**\n * Compare [semver](https://semver.org/) version strings to find greater, equal or lesser.\n * This library supports the full semver specification, including comparing versions with different number of digits like `1.0.0`, `1.0`, `1`, and pre-release versions like `1.0.0-alpha`.\n * @param v1 - First version to compare\n * @param v2 - Second version to compare\n * @returns Numeric value compatible with the [Array.sort(fn) interface](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/sort#Parameters).\n */\nexport const compareVersions = (v1, v2) => {\n  // validate input and split into segments\n  const n1 = validateAndParse(v1);\n  const n2 = validateAndParse(v2); // pop off the patch\n\n  const p1 = n1.pop();\n  const p2 = n2.pop(); // validate numbers\n\n  const r = compareSegments(n1, n2);\n  if (r !== 0) return r; // validate pre-release\n\n  if (p1 && p2) {\n    return compareSegments(p1.split('.'), p2.split('.'));\n  } else if (p1 || p2) {\n    return p1 ? -1 : 1;\n  }\n\n  return 0;\n};\n/**\n * Validate [semver](https://semver.org/) version strings.\n *\n * @param version Version number to validate\n * @returns `true` if the version number is a valid semver version number, `false` otherwise.\n *\n * @example\n * ```\n * validate('1.0.0-rc.1'); // return true\n * validate('1.0-rc.1'); // return false\n * validate('foo'); // return false\n * ```\n */\n\nexport const validate = version => typeof version === 'string' && /^[v\\d]/.test(version) && semver.test(version);\n/**\n * Compare [semver](https://semver.org/) version strings using the specified operator.\n *\n * @param v1 First version to compare\n * @param v2 Second version to compare\n * @param operator Allowed arithmetic operator to use\n * @returns `true` if the comparison between the firstVersion and the secondVersion satisfies the operator, `false` otherwise.\n *\n * @example\n * ```\n * compare('10.1.8', '10.0.4', '>'); // return true\n * compare('10.0.1', '10.0.1', '='); // return true\n * compare('10.1.1', '10.2.2', '<'); // return true\n * compare('10.1.1', '10.2.2', '<='); // return true\n * compare('10.1.1', '10.2.2', '>='); // return false\n * ```\n */\n\nexport const compare = (v1, v2, operator) => {\n  // validate input operator\n  assertValidOperator(operator); // since result of compareVersions can only be -1 or 0 or 1\n  // a simple map can be used to replace switch\n\n  const res = compareVersions(v1, v2);\n  return operatorResMap[operator].includes(res);\n};\n/**\n * Match [npm semver](https://docs.npmjs.com/cli/v6/using-npm/semver) version range.\n *\n * @param version Version number to match\n * @param range Range pattern for version\n * @returns `true` if the version number is within the range, `false` otherwise.\n *\n * @example\n * ```\n * satisfies('1.1.0', '^1.0.0'); // return true\n * satisfies('1.1.0', '~1.0.0'); // return false\n * ```\n */\n\nexport const satisfies = (version, range) => {\n  // if no range operator then \"=\"\n  const m = range.match(/^([<>=~^]+)/);\n  const op = m ? m[1] : '='; // if gt/lt/eq then operator compare\n\n  if (op !== '^' && op !== '~') return compare(version, range, op); // else range of either \"~\" or \"^\" is assumed\n\n  const [v1, v2, v3] = validateAndParse(version);\n  const [r1, r2, r3] = validateAndParse(range);\n  if (compareStrings(v1, r1) !== 0) return false;\n\n  if (op === '^') {\n    return compareSegments([v2, v3], [r2, r3]) >= 0;\n  }\n\n  if (compareStrings(v2, r2) !== 0) return false;\n  return compareStrings(v3, r3) >= 0;\n};\nconst semver = /^[v^~<>=]*?(\\d+)(?:\\.([x*]|\\d+)(?:\\.([x*]|\\d+)(?:\\.([x*]|\\d+))?(?:-([\\da-z\\-]+(?:\\.[\\da-z\\-]+)*))?(?:\\+[\\da-z\\-]+(?:\\.[\\da-z\\-]+)*)?)?)?$/i;\n\nconst validateAndParse = version => {\n  if (typeof version !== 'string') {\n    throw new TypeError('Invalid argument expected string');\n  }\n\n  const match = version.match(semver);\n\n  if (!match) {\n    throw new Error(`Invalid argument not valid semver ('${version}' received)`);\n  }\n\n  match.shift();\n  return match;\n};\n\nconst isWildcard = s => s === '*' || s === 'x' || s === 'X';\n\nconst tryParse = v => {\n  const n = parseInt(v, 10);\n  return isNaN(n) ? v : n;\n};\n\nconst forceType = (a, b) => typeof a !== typeof b ? [String(a), String(b)] : [a, b];\n\nconst compareStrings = (a, b) => {\n  if (isWildcard(a) || isWildcard(b)) return 0;\n  const [ap, bp] = forceType(tryParse(a), tryParse(b));\n  if (ap > bp) return 1;\n  if (ap < bp) return -1;\n  return 0;\n};\n\nconst compareSegments = (a, b) => {\n  for (let i = 0; i < Math.max(a.length, b.length); i++) {\n    const r = compareStrings(a[i] || '0', b[i] || '0');\n    if (r !== 0) return r;\n  }\n\n  return 0;\n};\n\nconst operatorResMap = {\n  '>': [1],\n  '>=': [0, 1],\n  '=': [0],\n  '<=': [-1, 0],\n  '<': [-1]\n};\nconst allowedOperators = Object.keys(operatorResMap);\n\nconst assertValidOperator = op => {\n  if (typeof op !== 'string') {\n    throw new TypeError(`Invalid operator type, expected string but got ${typeof op}`);\n  }\n\n  if (allowedOperators.indexOf(op) === -1) {\n    throw new Error(`Invalid operator, expected one of ${allowedOperators.join('|')}`);\n  }\n}; //# sourceMappingURL=index.js.map","map":null,"metadata":{},"sourceType":"module"}