{"ast":null,"code":"import _asyncToGenerator from \"C:/Users/Narean/source/repos/OktaDemon/OktaDemon/ClientApp/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\n\n/*!\n * Copyright (c) 2015-present, Okta, Inc. and/or its affiliates. All rights reserved.\n * The Okta software accompanied by this notice is provided pursuant to the Apache License, Version 2.0 (the \"License.\")\n *\n * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0.\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * \n * See the License for the specific language governing permissions and limitations under the License.\n */\nimport { clone } from '../util/object.js';\nimport { getOAuthUrls } from './util/oauth.js';\nimport AuthSdkError from '../errors/AuthSdkError.js';\nimport OAuthError from '../errors/OAuthError.js';\nimport { verifyToken } from './verifyToken.js';\nimport { getDefaultTokenParams } from './util/defaultTokenParams.js';\nimport 'tiny-emitter';\nimport 'js-cookie';\nimport 'cross-fetch';\n\nfunction validateResponse(res, oauthParams) {\n  if (res['error'] && res['error_description']) {\n    throw new OAuthError(res['error'], res['error_description']);\n  }\n\n  if (res.state !== oauthParams.state) {\n    throw new AuthSdkError('OAuth flow response state doesn\\'t match request state');\n  }\n}\n\nfunction handleOAuthResponse(_x, _x2, _x3, _x4) {\n  return _handleOAuthResponse.apply(this, arguments);\n}\n\nfunction _handleOAuthResponse() {\n  _handleOAuthResponse = _asyncToGenerator(function* (sdk, tokenParams, res, urls) {\n    var pkce = sdk.options.pkce !== false;\n\n    if (pkce && (res.code || res.interaction_code)) {\n      return sdk.token.exchangeCodeForTokens(Object.assign({}, tokenParams, {\n        authorizationCode: res.code,\n        interactionCode: res.interaction_code\n      }), urls);\n    }\n\n    tokenParams = tokenParams || getDefaultTokenParams(sdk);\n    urls = urls || getOAuthUrls(sdk, tokenParams);\n    var responseType = tokenParams.responseType || [];\n\n    if (!Array.isArray(responseType)) {\n      responseType = [responseType];\n    }\n\n    var scopes;\n\n    if (res.scope) {\n      scopes = res.scope.split(' ');\n    } else {\n      scopes = clone(tokenParams.scopes);\n    }\n\n    var clientId = tokenParams.clientId || sdk.options.clientId;\n    validateResponse(res, tokenParams);\n    var tokenDict = {};\n    var expiresIn = res.expires_in;\n    var tokenType = res.token_type;\n    var accessToken = res.access_token;\n    var idToken = res.id_token;\n    var refreshToken = res.refresh_token;\n    var now = Math.floor(Date.now() / 1000);\n\n    if (accessToken) {\n      var accessJwt = sdk.token.decode(accessToken);\n      tokenDict.accessToken = {\n        accessToken: accessToken,\n        claims: accessJwt.payload,\n        expiresAt: Number(expiresIn) + now,\n        tokenType: tokenType,\n        scopes: scopes,\n        authorizeUrl: urls.authorizeUrl,\n        userinfoUrl: urls.userinfoUrl\n      };\n    }\n\n    if (refreshToken) {\n      tokenDict.refreshToken = {\n        refreshToken: refreshToken,\n        expiresAt: Number(expiresIn) + now,\n        scopes: scopes,\n        tokenUrl: urls.tokenUrl,\n        authorizeUrl: urls.authorizeUrl,\n        issuer: urls.issuer\n      };\n    }\n\n    if (idToken) {\n      var idJwt = sdk.token.decode(idToken);\n      var idTokenObj = {\n        idToken: idToken,\n        claims: idJwt.payload,\n        expiresAt: idJwt.payload.exp - idJwt.payload.iat + now,\n        scopes: scopes,\n        authorizeUrl: urls.authorizeUrl,\n        issuer: urls.issuer,\n        clientId: clientId\n      };\n      var validationParams = {\n        clientId: clientId,\n        issuer: urls.issuer,\n        nonce: tokenParams.nonce,\n        accessToken: accessToken\n      };\n\n      if (tokenParams.ignoreSignature !== undefined) {\n        validationParams.ignoreSignature = tokenParams.ignoreSignature;\n      }\n\n      yield verifyToken(sdk, idTokenObj, validationParams);\n      tokenDict.idToken = idTokenObj;\n    }\n\n    if (responseType.indexOf('token') !== -1 && !tokenDict.accessToken) {\n      throw new AuthSdkError('Unable to parse OAuth flow response: response type \"token\" was requested but \"access_token\" was not returned.');\n    }\n\n    if (responseType.indexOf('id_token') !== -1 && !tokenDict.idToken) {\n      throw new AuthSdkError('Unable to parse OAuth flow response: response type \"id_token\" was requested but \"id_token\" was not returned.');\n    }\n\n    return {\n      tokens: tokenDict,\n      state: res.state,\n      code: res.code\n    };\n  });\n  return _handleOAuthResponse.apply(this, arguments);\n}\n\nexport { handleOAuthResponse }; //# sourceMappingURL=handleOAuthResponse.js.map","map":null,"metadata":{},"sourceType":"module"}