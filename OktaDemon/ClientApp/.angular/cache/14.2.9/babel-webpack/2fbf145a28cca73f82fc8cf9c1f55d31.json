{"ast":null,"code":"import _asyncToGenerator from \"C:/Users/Narean/source/repos/OktaDemon/OktaDemon/ClientApp/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\n\n/*!\n * Copyright (c) 2015-present, Okta, Inc. and/or its affiliates. All rights reserved.\n * The Okta software accompanied by this notice is provided pursuant to the Apache License, Version 2.0 (the \"License.\")\n *\n * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0.\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * \n * See the License for the specific language governing permissions and limitations under the License.\n */\nimport { __rest } from '../_virtual/_tslib.js';\nimport { warn } from '../util/console.js';\nimport { split2 } from '../util/misc.js';\nimport * as index from './remediators/index.js';\nimport { GenericRemediator } from './remediators/GenericRemediator/GenericRemediator.js';\nimport { IdxFeature } from './types/api.js';\n\nfunction isTerminalResponse(idxResponse) {\n  const {\n    neededToProceed,\n    interactionCode\n  } = idxResponse;\n  return !neededToProceed.length && !interactionCode;\n}\n\nfunction canSkipFn(idxResponse) {\n  return idxResponse.neededToProceed.some(({\n    name\n  }) => name === 'skip');\n}\n\nfunction canResendFn(idxResponse) {\n  return Object.keys(idxResponse.actions).some(actionName => actionName.includes('resend'));\n}\n\nfunction getMessagesFromIdxRemediationValue(value) {\n  if (!value || !Array.isArray(value)) {\n    return;\n  }\n\n  return value.reduce((messages, value) => {\n    if (value.messages) {\n      messages = [...messages, ...value.messages.value];\n    }\n\n    if (value.form) {\n      const messagesFromForm = getMessagesFromIdxRemediationValue(value.form.value) || [];\n      messages = [...messages, ...messagesFromForm];\n    }\n\n    if (value.options) {\n      let optionValues = [];\n      value.options.forEach(option => {\n        if (!option.value || typeof option.value === 'string') {\n          return;\n        }\n\n        optionValues = [...optionValues, option.value];\n      });\n      const messagesFromOptions = getMessagesFromIdxRemediationValue(optionValues) || [];\n      messages = [...messages, ...messagesFromOptions];\n    }\n\n    return messages;\n  }, []);\n}\n\nfunction getMessagesFromResponse(idxResponse, options) {\n  var _a;\n\n  let messages = [];\n  const {\n    rawIdxState,\n    neededToProceed\n  } = idxResponse;\n  const globalMessages = (_a = rawIdxState.messages) === null || _a === void 0 ? void 0 : _a.value.map(message => message);\n\n  if (globalMessages) {\n    messages = [...messages, ...globalMessages];\n  }\n\n  if (!options.useGenericRemediator) {\n    for (let remediation of neededToProceed) {\n      const fieldMessages = getMessagesFromIdxRemediationValue(remediation.value);\n\n      if (fieldMessages) {\n        messages = [...messages, ...fieldMessages];\n      }\n    }\n  }\n\n  const seen = {};\n  messages = messages.reduce((filtered, message) => {\n    var _a;\n\n    const key = (_a = message.i18n) === null || _a === void 0 ? void 0 : _a.key;\n\n    if (key && seen[key]) {\n      return filtered;\n    }\n\n    seen[key] = message;\n    filtered = [...filtered, message];\n    return filtered;\n  }, []);\n  return messages;\n}\n\nfunction getEnabledFeatures(idxResponse) {\n  const res = [];\n  const {\n    actions,\n    neededToProceed\n  } = idxResponse;\n\n  if (actions['currentAuthenticator-recover']) {\n    res.push(IdxFeature.PASSWORD_RECOVERY);\n  }\n\n  if (neededToProceed.some(({\n    name\n  }) => name === 'select-enroll-profile')) {\n    res.push(IdxFeature.REGISTRATION);\n  }\n\n  if (neededToProceed.some(({\n    name\n  }) => name === 'redirect-idp')) {\n    res.push(IdxFeature.SOCIAL_IDP);\n  }\n\n  if (neededToProceed.some(({\n    name\n  }) => name === 'unlock-account')) {\n    res.push(IdxFeature.ACCOUNT_UNLOCK);\n  }\n\n  return res;\n}\n\nfunction getAvailableSteps(authClient, idxResponse, useGenericRemediator) {\n  var _a;\n\n  const res = [];\n  const remediatorMap = Object.values(index).reduce((map, remediatorClass) => {\n    if (remediatorClass.remediationName) {\n      map[remediatorClass.remediationName] = remediatorClass;\n    }\n\n    return map;\n  }, {});\n\n  for (let remediation of idxResponse.neededToProceed) {\n    const T = getRemediatorClass(remediation, {\n      useGenericRemediator,\n      remediators: remediatorMap\n    });\n\n    if (T) {\n      const remediator = new T(remediation);\n      res.push(remediator.getNextStep(authClient, idxResponse.context));\n    }\n  }\n\n  for (const [name] of Object.entries(idxResponse.actions || {})) {\n    let stepObj = {\n      name,\n      action: function () {\n        var _ref = _asyncToGenerator(function* (params) {\n          return authClient.idx.proceed({\n            actions: [{\n              name,\n              params\n            }]\n          });\n        });\n\n        return function action(_x) {\n          return _ref.apply(this, arguments);\n        };\n      }()\n    };\n\n    if (name.startsWith('currentAuthenticator')) {\n      const [part1, part2] = split2(name, '-');\n      const actionObj = idxResponse.rawIdxState[part1].value[part2];\n\n      const rest = __rest(actionObj, [\"href\", \"method\", \"rel\", \"accepts\", \"produces\"]);\n\n      const value = (_a = actionObj.value) === null || _a === void 0 ? void 0 : _a.filter(item => item.name !== 'stateHandle');\n      stepObj = Object.assign(Object.assign(Object.assign({}, rest), value && {\n        value\n      }), stepObj);\n    }\n\n    res.push(stepObj);\n  }\n\n  return res;\n}\n\nfunction filterValuesForRemediation(idxResponse, remediationName, values) {\n  const remediations = idxResponse.neededToProceed || [];\n  const remediation = remediations.find(r => r.name === remediationName);\n\n  if (!remediation) {\n    warn(`filterValuesForRemediation: \"${remediationName}\" did not match any remediations`);\n    return values;\n  }\n\n  const valuesForRemediation = remediation.value.reduce((res, entry) => {\n    const {\n      name,\n      value\n    } = entry;\n\n    if (name === 'stateHandle') {\n      res[name] = value;\n    } else {\n      res[name] = values[name];\n    }\n\n    return res;\n  }, {});\n  return valuesForRemediation;\n}\n\nfunction getRemediatorClass(remediation, options) {\n  const {\n    useGenericRemediator,\n    remediators\n  } = options;\n\n  if (!remediation) {\n    return undefined;\n  }\n\n  if (useGenericRemediator) {\n    return GenericRemediator;\n  }\n\n  return remediators[remediation.name];\n}\n\nfunction getRemediator(idxRemediations, values, options) {\n  const remediators = options.remediators;\n  const useGenericRemediator = options.useGenericRemediator;\n  let remediator;\n\n  if (options.step) {\n    const remediation = idxRemediations.find(({\n      name\n    }) => name === options.step);\n\n    if (remediation) {\n      const T = getRemediatorClass(remediation, options);\n      return T ? new T(remediation, values, options) : undefined;\n    } else {\n      warn(`step \"${options.step}\" did not match any remediations`);\n      return;\n    }\n  }\n\n  const remediatorCandidates = [];\n\n  if (useGenericRemediator) {\n    remediatorCandidates.push(new GenericRemediator(idxRemediations[0], values, options));\n  } else {\n    for (let remediation of idxRemediations) {\n      const isRemeditionInFlow = Object.keys(remediators).includes(remediation.name);\n\n      if (!isRemeditionInFlow) {\n        continue;\n      }\n\n      const T = getRemediatorClass(remediation, options);\n      remediator = new T(remediation, values, options);\n\n      if (remediator.canRemediate()) {\n        return remediator;\n      }\n\n      remediatorCandidates.push(remediator);\n    }\n  }\n\n  return remediatorCandidates[0];\n}\n\nfunction getNextStep(authClient, remediator, idxResponse) {\n  const nextStep = remediator.getNextStep(authClient, idxResponse.context);\n  const canSkip = canSkipFn(idxResponse);\n  const canResend = canResendFn(idxResponse);\n  return Object.assign(Object.assign(Object.assign({}, nextStep), canSkip && {\n    canSkip\n  }), canResend && {\n    canResend\n  });\n}\n\nfunction handleFailedResponse(authClient, idxResponse, options = {}) {\n  const terminal = isTerminalResponse(idxResponse);\n  const messages = getMessagesFromResponse(idxResponse, options);\n\n  if (terminal) {\n    return {\n      idxResponse,\n      terminal,\n      messages\n    };\n  } else {\n    const remediator = getRemediator(idxResponse.neededToProceed, {}, options);\n    const nextStep = remediator && getNextStep(authClient, remediator, idxResponse);\n    return Object.assign({\n      idxResponse,\n      messages\n    }, nextStep && {\n      nextStep\n    });\n  }\n}\n\nexport { canResendFn, canSkipFn, filterValuesForRemediation, getAvailableSteps, getEnabledFeatures, getMessagesFromIdxRemediationValue, getMessagesFromResponse, getNextStep, getRemediator, handleFailedResponse, isTerminalResponse }; //# sourceMappingURL=util.js.map","map":null,"metadata":{},"sourceType":"module"}