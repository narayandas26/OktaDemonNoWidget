{"ast":null,"code":"/**\n * Compare [semver](https://semver.org/) version strings to find greater, equal or lesser.\n * This library supports the full semver specification, including comparing versions with different number of digits like `1.0.0`, `1.0`, `1`, and pre-release versions like `1.0.0-alpha`.\n * @param v1 - First version to compare\n * @param v2 - Second version to compare\n * @returns Numeric value compatible with the [Array.sort(fn) interface](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/sort#Parameters).\n */\nexport const compareVersions = (v1, v2) => {\n  // validate input and split into segments\n  const n1 = validateAndParse(v1);\n  const n2 = validateAndParse(v2); // pop off the patch\n\n  const p1 = n1.pop();\n  const p2 = n2.pop(); // validate numbers\n\n  const r = compareSegments(n1, n2);\n  if (r !== 0) return r; // validate pre-release\n\n  if (p1 && p2) {\n    return compareSegments(p1.split('.'), p2.split('.'));\n  } else if (p1 || p2) {\n    return p1 ? -1 : 1;\n  }\n\n  return 0;\n};\n/**\n * Validate [semver](https://semver.org/) version strings.\n *\n * @param version Version number to validate\n * @returns `true` if the version number is a valid semver version number, `false` otherwise.\n *\n * @example\n * ```\n * validate('1.0.0-rc.1'); // return true\n * validate('1.0-rc.1'); // return false\n * validate('foo'); // return false\n * ```\n */\n\nexport const validate = version => typeof version === 'string' && /^[v\\d]/.test(version) && semver.test(version);\n/**\n * Compare [semver](https://semver.org/) version strings using the specified operator.\n *\n * @param v1 First version to compare\n * @param v2 Second version to compare\n * @param operator Allowed arithmetic operator to use\n * @returns `true` if the comparison between the firstVersion and the secondVersion satisfies the operator, `false` otherwise.\n *\n * @example\n * ```\n * compare('10.1.8', '10.0.4', '>'); // return true\n * compare('10.0.1', '10.0.1', '='); // return true\n * compare('10.1.1', '10.2.2', '<'); // return true\n * compare('10.1.1', '10.2.2', '<='); // return true\n * compare('10.1.1', '10.2.2', '>='); // return false\n * ```\n */\n\nexport const compare = (v1, v2, operator) => {\n  // validate input operator\n  assertValidOperator(operator); // since result of compareVersions can only be -1 or 0 or 1\n  // a simple map can be used to replace switch\n\n  const res = compareVersions(v1, v2);\n  return operatorResMap[operator].includes(res);\n};\n/**\n * Match [npm semver](https://docs.npmjs.com/cli/v6/using-npm/semver) version range.\n *\n * @param version Version number to match\n * @param range Range pattern for version\n * @returns `true` if the version number is within the range, `false` otherwise.\n *\n * @example\n * ```\n * satisfies('1.1.0', '^1.0.0'); // return true\n * satisfies('1.1.0', '~1.0.0'); // return false\n * ```\n */\n\nexport const satisfies = (version, range) => {\n  // if no range operator then \"=\"\n  const m = range.match(/^([<>=~^]+)/);\n  const op = m ? m[1] : '='; // if gt/lt/eq then operator compare\n\n  if (op !== '^' && op !== '~') return compare(version, range, op); // else range of either \"~\" or \"^\" is assumed\n\n  const [v1, v2, v3] = validateAndParse(version);\n  const [r1, r2, r3] = validateAndParse(range);\n  if (compareStrings(v1, r1) !== 0) return false;\n\n  if (op === '^') {\n    return compareSegments([v2, v3], [r2, r3]) >= 0;\n  }\n\n  if (compareStrings(v2, r2) !== 0) return false;\n  return compareStrings(v3, r3) >= 0;\n};\nconst semver = /^[v^~<>=]*?(\\d+)(?:\\.([x*]|\\d+)(?:\\.([x*]|\\d+)(?:\\.([x*]|\\d+))?(?:-([\\da-z\\-]+(?:\\.[\\da-z\\-]+)*))?(?:\\+[\\da-z\\-]+(?:\\.[\\da-z\\-]+)*)?)?)?$/i;\n\nconst validateAndParse = version => {\n  if (typeof version !== 'string') {\n    throw new TypeError('Invalid argument expected string');\n  }\n\n  const match = version.match(semver);\n\n  if (!match) {\n    throw new Error(`Invalid argument not valid semver ('${version}' received)`);\n  }\n\n  match.shift();\n  return match;\n};\n\nconst isWildcard = s => s === '*' || s === 'x' || s === 'X';\n\nconst tryParse = v => {\n  const n = parseInt(v, 10);\n  return isNaN(n) ? v : n;\n};\n\nconst forceType = (a, b) => typeof a !== typeof b ? [String(a), String(b)] : [a, b];\n\nconst compareStrings = (a, b) => {\n  if (isWildcard(a) || isWildcard(b)) return 0;\n  const [ap, bp] = forceType(tryParse(a), tryParse(b));\n  if (ap > bp) return 1;\n  if (ap < bp) return -1;\n  return 0;\n};\n\nconst compareSegments = (a, b) => {\n  for (let i = 0; i < Math.max(a.length, b.length); i++) {\n    const r = compareStrings(a[i] || '0', b[i] || '0');\n    if (r !== 0) return r;\n  }\n\n  return 0;\n};\n\nconst operatorResMap = {\n  '>': [1],\n  '>=': [0, 1],\n  '=': [0],\n  '<=': [-1, 0],\n  '<': [-1]\n};\nconst allowedOperators = Object.keys(operatorResMap);\n\nconst assertValidOperator = op => {\n  if (typeof op !== 'string') {\n    throw new TypeError(`Invalid operator type, expected string but got ${typeof op}`);\n  }\n\n  if (allowedOperators.indexOf(op) === -1) {\n    throw new Error(`Invalid operator, expected one of ${allowedOperators.join('|')}`);\n  }\n};","map":{"version":3,"names":["compareVersions","v1","v2","n1","validateAndParse","n2","p1","pop","p2","r","compareSegments","split","validate","version","test","semver","compare","operator","assertValidOperator","res","operatorResMap","includes","satisfies","range","m","match","op","v3","r1","r2","r3","compareStrings","TypeError","Error","shift","isWildcard","s","tryParse","v","n","parseInt","isNaN","forceType","a","b","String","ap","bp","i","Math","max","length","allowedOperators","Object","keys","indexOf","join"],"sources":["C:/Users/Narean/source/repos/OktaDemon/OktaDemon/ClientApp/node_modules/compare-versions/lib/esm/index.js"],"sourcesContent":["/**\n * Compare [semver](https://semver.org/) version strings to find greater, equal or lesser.\n * This library supports the full semver specification, including comparing versions with different number of digits like `1.0.0`, `1.0`, `1`, and pre-release versions like `1.0.0-alpha`.\n * @param v1 - First version to compare\n * @param v2 - Second version to compare\n * @returns Numeric value compatible with the [Array.sort(fn) interface](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/sort#Parameters).\n */\nexport const compareVersions = (v1, v2) => {\n    // validate input and split into segments\n    const n1 = validateAndParse(v1);\n    const n2 = validateAndParse(v2);\n    // pop off the patch\n    const p1 = n1.pop();\n    const p2 = n2.pop();\n    // validate numbers\n    const r = compareSegments(n1, n2);\n    if (r !== 0)\n        return r;\n    // validate pre-release\n    if (p1 && p2) {\n        return compareSegments(p1.split('.'), p2.split('.'));\n    }\n    else if (p1 || p2) {\n        return p1 ? -1 : 1;\n    }\n    return 0;\n};\n/**\n * Validate [semver](https://semver.org/) version strings.\n *\n * @param version Version number to validate\n * @returns `true` if the version number is a valid semver version number, `false` otherwise.\n *\n * @example\n * ```\n * validate('1.0.0-rc.1'); // return true\n * validate('1.0-rc.1'); // return false\n * validate('foo'); // return false\n * ```\n */\nexport const validate = (version) => typeof version === 'string' && /^[v\\d]/.test(version) && semver.test(version);\n/**\n * Compare [semver](https://semver.org/) version strings using the specified operator.\n *\n * @param v1 First version to compare\n * @param v2 Second version to compare\n * @param operator Allowed arithmetic operator to use\n * @returns `true` if the comparison between the firstVersion and the secondVersion satisfies the operator, `false` otherwise.\n *\n * @example\n * ```\n * compare('10.1.8', '10.0.4', '>'); // return true\n * compare('10.0.1', '10.0.1', '='); // return true\n * compare('10.1.1', '10.2.2', '<'); // return true\n * compare('10.1.1', '10.2.2', '<='); // return true\n * compare('10.1.1', '10.2.2', '>='); // return false\n * ```\n */\nexport const compare = (v1, v2, operator) => {\n    // validate input operator\n    assertValidOperator(operator);\n    // since result of compareVersions can only be -1 or 0 or 1\n    // a simple map can be used to replace switch\n    const res = compareVersions(v1, v2);\n    return operatorResMap[operator].includes(res);\n};\n/**\n * Match [npm semver](https://docs.npmjs.com/cli/v6/using-npm/semver) version range.\n *\n * @param version Version number to match\n * @param range Range pattern for version\n * @returns `true` if the version number is within the range, `false` otherwise.\n *\n * @example\n * ```\n * satisfies('1.1.0', '^1.0.0'); // return true\n * satisfies('1.1.0', '~1.0.0'); // return false\n * ```\n */\nexport const satisfies = (version, range) => {\n    // if no range operator then \"=\"\n    const m = range.match(/^([<>=~^]+)/);\n    const op = m ? m[1] : '=';\n    // if gt/lt/eq then operator compare\n    if (op !== '^' && op !== '~')\n        return compare(version, range, op);\n    // else range of either \"~\" or \"^\" is assumed\n    const [v1, v2, v3] = validateAndParse(version);\n    const [r1, r2, r3] = validateAndParse(range);\n    if (compareStrings(v1, r1) !== 0)\n        return false;\n    if (op === '^') {\n        return compareSegments([v2, v3], [r2, r3]) >= 0;\n    }\n    if (compareStrings(v2, r2) !== 0)\n        return false;\n    return compareStrings(v3, r3) >= 0;\n};\nconst semver = /^[v^~<>=]*?(\\d+)(?:\\.([x*]|\\d+)(?:\\.([x*]|\\d+)(?:\\.([x*]|\\d+))?(?:-([\\da-z\\-]+(?:\\.[\\da-z\\-]+)*))?(?:\\+[\\da-z\\-]+(?:\\.[\\da-z\\-]+)*)?)?)?$/i;\nconst validateAndParse = (version) => {\n    if (typeof version !== 'string') {\n        throw new TypeError('Invalid argument expected string');\n    }\n    const match = version.match(semver);\n    if (!match) {\n        throw new Error(`Invalid argument not valid semver ('${version}' received)`);\n    }\n    match.shift();\n    return match;\n};\nconst isWildcard = (s) => s === '*' || s === 'x' || s === 'X';\nconst tryParse = (v) => {\n    const n = parseInt(v, 10);\n    return isNaN(n) ? v : n;\n};\nconst forceType = (a, b) => typeof a !== typeof b ? [String(a), String(b)] : [a, b];\nconst compareStrings = (a, b) => {\n    if (isWildcard(a) || isWildcard(b))\n        return 0;\n    const [ap, bp] = forceType(tryParse(a), tryParse(b));\n    if (ap > bp)\n        return 1;\n    if (ap < bp)\n        return -1;\n    return 0;\n};\nconst compareSegments = (a, b) => {\n    for (let i = 0; i < Math.max(a.length, b.length); i++) {\n        const r = compareStrings(a[i] || '0', b[i] || '0');\n        if (r !== 0)\n            return r;\n    }\n    return 0;\n};\nconst operatorResMap = {\n    '>': [1],\n    '>=': [0, 1],\n    '=': [0],\n    '<=': [-1, 0],\n    '<': [-1],\n};\nconst allowedOperators = Object.keys(operatorResMap);\nconst assertValidOperator = (op) => {\n    if (typeof op !== 'string') {\n        throw new TypeError(`Invalid operator type, expected string but got ${typeof op}`);\n    }\n    if (allowedOperators.indexOf(op) === -1) {\n        throw new Error(`Invalid operator, expected one of ${allowedOperators.join('|')}`);\n    }\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}