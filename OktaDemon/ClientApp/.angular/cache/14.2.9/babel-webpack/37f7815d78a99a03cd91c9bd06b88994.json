{"ast":null,"code":"import _asyncToGenerator from \"C:/Users/Narean/source/repos/OktaDemon/OktaDemon/ClientApp/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\n\n/*!\n * Copyright (c) 2015-present, Okta, Inc. and/or its affiliates. All rights reserved.\n * The Okta software accompanied by this notice is provided pursuant to the Apache License, Version 2.0 (the \"License.\")\n *\n * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0.\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * \n * See the License for the specific language governing permissions and limitations under the License.\n */\nimport { getWellKnown } from '../endpoints/well-known.js';\nimport AuthSdkError from '../../errors/AuthSdkError.js';\nimport { getDefaultTokenParams } from './defaultTokenParams.js';\nimport { DEFAULT_CODE_CHALLENGE_METHOD } from '../../constants.js';\nimport PKCE from './pkce.js';\n\nfunction assertPKCESupport(sdk) {\n  if (!sdk.features.isPKCESupported()) {\n    var errorMessage = 'PKCE requires a modern browser with encryption support running in a secure context.';\n\n    if (!sdk.features.isHTTPS()) {\n      errorMessage += '\\nThe current page is not being served with HTTPS protocol. PKCE requires secure HTTPS protocol.';\n    }\n\n    if (!sdk.features.hasTextEncoder()) {\n      errorMessage += '\\n\"TextEncoder\" is not defined. To use PKCE, you may need to include a polyfill/shim for this browser.';\n    }\n\n    throw new AuthSdkError(errorMessage);\n  }\n}\n\nfunction validateCodeChallengeMethod(_x, _x2) {\n  return _validateCodeChallengeMethod.apply(this, arguments);\n}\n\nfunction _validateCodeChallengeMethod() {\n  _validateCodeChallengeMethod = _asyncToGenerator(function* (sdk, codeChallengeMethod) {\n    codeChallengeMethod = codeChallengeMethod || sdk.options.codeChallengeMethod || DEFAULT_CODE_CHALLENGE_METHOD;\n    const wellKnownResponse = yield getWellKnown(sdk);\n    var methods = wellKnownResponse['code_challenge_methods_supported'] || [];\n\n    if (methods.indexOf(codeChallengeMethod) === -1) {\n      throw new AuthSdkError('Invalid code_challenge_method');\n    }\n\n    return codeChallengeMethod;\n  });\n  return _validateCodeChallengeMethod.apply(this, arguments);\n}\n\nfunction preparePKCE(_x3, _x4) {\n  return _preparePKCE.apply(this, arguments);\n}\n\nfunction _preparePKCE() {\n  _preparePKCE = _asyncToGenerator(function* (sdk, tokenParams) {\n    let {\n      codeVerifier,\n      codeChallenge,\n      codeChallengeMethod\n    } = tokenParams;\n    codeChallenge = codeChallenge || sdk.options.codeChallenge;\n\n    if (!codeChallenge) {\n      assertPKCESupport(sdk);\n      codeVerifier = codeVerifier || PKCE.generateVerifier();\n      codeChallenge = yield PKCE.computeChallenge(codeVerifier);\n    }\n\n    codeChallengeMethod = yield validateCodeChallengeMethod(sdk, codeChallengeMethod);\n    tokenParams = Object.assign(Object.assign({}, tokenParams), {\n      responseType: 'code',\n      codeVerifier,\n      codeChallenge,\n      codeChallengeMethod\n    });\n    return tokenParams;\n  });\n  return _preparePKCE.apply(this, arguments);\n}\n\nfunction prepareTokenParams(_x5) {\n  return _prepareTokenParams.apply(this, arguments);\n}\n\nfunction _prepareTokenParams() {\n  _prepareTokenParams = _asyncToGenerator(function* (sdk, tokenParams = {}) {\n    const defaults = getDefaultTokenParams(sdk);\n    tokenParams = Object.assign(Object.assign({}, defaults), tokenParams);\n\n    if (tokenParams.pkce === false) {\n      return tokenParams;\n    }\n\n    return preparePKCE(sdk, tokenParams);\n  });\n  return _prepareTokenParams.apply(this, arguments);\n}\n\nexport { assertPKCESupport, preparePKCE, prepareTokenParams, validateCodeChallengeMethod };","map":{"version":3,"names":["getWellKnown","AuthSdkError","getDefaultTokenParams","DEFAULT_CODE_CHALLENGE_METHOD","PKCE","assertPKCESupport","sdk","features","isPKCESupported","errorMessage","isHTTPS","hasTextEncoder","validateCodeChallengeMethod","codeChallengeMethod","options","wellKnownResponse","methods","indexOf","preparePKCE","tokenParams","codeVerifier","codeChallenge","generateVerifier","computeChallenge","Object","assign","responseType","prepareTokenParams","defaults","pkce"],"sources":["C:/Users/Narean/source/repos/OktaDemon/OktaDemon/ClientApp/node_modules/@okta/okta-auth-js/esm/browser/oidc/util/prepareTokenParams.js"],"sourcesContent":["/*!\n * Copyright (c) 2015-present, Okta, Inc. and/or its affiliates. All rights reserved.\n * The Okta software accompanied by this notice is provided pursuant to the Apache License, Version 2.0 (the \"License.\")\n *\n * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0.\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * \n * See the License for the specific language governing permissions and limitations under the License.\n */\n\nimport { getWellKnown } from '../endpoints/well-known.js';\nimport AuthSdkError from '../../errors/AuthSdkError.js';\nimport { getDefaultTokenParams } from './defaultTokenParams.js';\nimport { DEFAULT_CODE_CHALLENGE_METHOD } from '../../constants.js';\nimport PKCE from './pkce.js';\n\nfunction assertPKCESupport(sdk) {\n    if (!sdk.features.isPKCESupported()) {\n        var errorMessage = 'PKCE requires a modern browser with encryption support running in a secure context.';\n        if (!sdk.features.isHTTPS()) {\n            errorMessage += '\\nThe current page is not being served with HTTPS protocol. PKCE requires secure HTTPS protocol.';\n        }\n        if (!sdk.features.hasTextEncoder()) {\n            errorMessage += '\\n\"TextEncoder\" is not defined. To use PKCE, you may need to include a polyfill/shim for this browser.';\n        }\n        throw new AuthSdkError(errorMessage);\n    }\n}\nasync function validateCodeChallengeMethod(sdk, codeChallengeMethod) {\n    codeChallengeMethod = codeChallengeMethod || sdk.options.codeChallengeMethod || DEFAULT_CODE_CHALLENGE_METHOD;\n    const wellKnownResponse = await getWellKnown(sdk);\n    var methods = wellKnownResponse['code_challenge_methods_supported'] || [];\n    if (methods.indexOf(codeChallengeMethod) === -1) {\n        throw new AuthSdkError('Invalid code_challenge_method');\n    }\n    return codeChallengeMethod;\n}\nasync function preparePKCE(sdk, tokenParams) {\n    let { codeVerifier, codeChallenge, codeChallengeMethod } = tokenParams;\n    codeChallenge = codeChallenge || sdk.options.codeChallenge;\n    if (!codeChallenge) {\n        assertPKCESupport(sdk);\n        codeVerifier = codeVerifier || PKCE.generateVerifier();\n        codeChallenge = await PKCE.computeChallenge(codeVerifier);\n    }\n    codeChallengeMethod = await validateCodeChallengeMethod(sdk, codeChallengeMethod);\n    tokenParams = Object.assign(Object.assign({}, tokenParams), { responseType: 'code',\n        codeVerifier,\n        codeChallenge,\n        codeChallengeMethod });\n    return tokenParams;\n}\nasync function prepareTokenParams(sdk, tokenParams = {}) {\n    const defaults = getDefaultTokenParams(sdk);\n    tokenParams = Object.assign(Object.assign({}, defaults), tokenParams);\n    if (tokenParams.pkce === false) {\n        return tokenParams;\n    }\n    return preparePKCE(sdk, tokenParams);\n}\n\nexport { assertPKCESupport, preparePKCE, prepareTokenParams, validateCodeChallengeMethod };\n"],"mappings":";;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA,SAASA,YAAT,QAA6B,4BAA7B;AACA,OAAOC,YAAP,MAAyB,8BAAzB;AACA,SAASC,qBAAT,QAAsC,yBAAtC;AACA,SAASC,6BAAT,QAA8C,oBAA9C;AACA,OAAOC,IAAP,MAAiB,WAAjB;;AAEA,SAASC,iBAAT,CAA2BC,GAA3B,EAAgC;EAC5B,IAAI,CAACA,GAAG,CAACC,QAAJ,CAAaC,eAAb,EAAL,EAAqC;IACjC,IAAIC,YAAY,GAAG,qFAAnB;;IACA,IAAI,CAACH,GAAG,CAACC,QAAJ,CAAaG,OAAb,EAAL,EAA6B;MACzBD,YAAY,IAAI,kGAAhB;IACH;;IACD,IAAI,CAACH,GAAG,CAACC,QAAJ,CAAaI,cAAb,EAAL,EAAoC;MAChCF,YAAY,IAAI,wGAAhB;IACH;;IACD,MAAM,IAAIR,YAAJ,CAAiBQ,YAAjB,CAAN;EACH;AACJ;;SACcG,2B;;;;;mDAAf,WAA2CN,GAA3C,EAAgDO,mBAAhD,EAAqE;IACjEA,mBAAmB,GAAGA,mBAAmB,IAAIP,GAAG,CAACQ,OAAJ,CAAYD,mBAAnC,IAA0DV,6BAAhF;IACA,MAAMY,iBAAiB,SAASf,YAAY,CAACM,GAAD,CAA5C;IACA,IAAIU,OAAO,GAAGD,iBAAiB,CAAC,kCAAD,CAAjB,IAAyD,EAAvE;;IACA,IAAIC,OAAO,CAACC,OAAR,CAAgBJ,mBAAhB,MAAyC,CAAC,CAA9C,EAAiD;MAC7C,MAAM,IAAIZ,YAAJ,CAAiB,+BAAjB,CAAN;IACH;;IACD,OAAOY,mBAAP;EACH,C;;;;SACcK,W;;;;;mCAAf,WAA2BZ,GAA3B,EAAgCa,WAAhC,EAA6C;IACzC,IAAI;MAAEC,YAAF;MAAgBC,aAAhB;MAA+BR;IAA/B,IAAuDM,WAA3D;IACAE,aAAa,GAAGA,aAAa,IAAIf,GAAG,CAACQ,OAAJ,CAAYO,aAA7C;;IACA,IAAI,CAACA,aAAL,EAAoB;MAChBhB,iBAAiB,CAACC,GAAD,CAAjB;MACAc,YAAY,GAAGA,YAAY,IAAIhB,IAAI,CAACkB,gBAAL,EAA/B;MACAD,aAAa,SAASjB,IAAI,CAACmB,gBAAL,CAAsBH,YAAtB,CAAtB;IACH;;IACDP,mBAAmB,SAASD,2BAA2B,CAACN,GAAD,EAAMO,mBAAN,CAAvD;IACAM,WAAW,GAAGK,MAAM,CAACC,MAAP,CAAcD,MAAM,CAACC,MAAP,CAAc,EAAd,EAAkBN,WAAlB,CAAd,EAA8C;MAAEO,YAAY,EAAE,MAAhB;MACxDN,YADwD;MAExDC,aAFwD;MAGxDR;IAHwD,CAA9C,CAAd;IAIA,OAAOM,WAAP;EACH,C;;;;SACcQ,kB;;;;;0CAAf,WAAkCrB,GAAlC,EAAuCa,WAAW,GAAG,EAArD,EAAyD;IACrD,MAAMS,QAAQ,GAAG1B,qBAAqB,CAACI,GAAD,CAAtC;IACAa,WAAW,GAAGK,MAAM,CAACC,MAAP,CAAcD,MAAM,CAACC,MAAP,CAAc,EAAd,EAAkBG,QAAlB,CAAd,EAA2CT,WAA3C,CAAd;;IACA,IAAIA,WAAW,CAACU,IAAZ,KAAqB,KAAzB,EAAgC;MAC5B,OAAOV,WAAP;IACH;;IACD,OAAOD,WAAW,CAACZ,GAAD,EAAMa,WAAN,CAAlB;EACH,C;;;;AAED,SAASd,iBAAT,EAA4Ba,WAA5B,EAAyCS,kBAAzC,EAA6Df,2BAA7D"},"metadata":{},"sourceType":"module"}