{"ast":null,"code":"import _asyncToGenerator from \"C:/Users/Narean/source/repos/OktaDemon/OktaDemon/ClientApp/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\n\n/*!\n * Copyright (c) 2015-present, Okta, Inc. and/or its affiliates. All rights reserved.\n * The Okta software accompanied by this notice is provided pursuant to the Apache License, Version 2.0 (the \"License.\")\n *\n * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0.\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * \n * See the License for the specific language governing permissions and limitations under the License.\n */\nimport ProfileTransaction from './transactions/ProfileTransaction.js';\nimport ProfileSchemaTransaction from './transactions/ProfileSchemaTransaction.js';\nimport EmailTransaction from './transactions/EmailTransaction.js';\nimport EmailStatusTransaction from './transactions/EmailStatusTransaction.js';\nimport EmailChallengeTransaction from './transactions/EmailChallengeTransaction.js';\nimport PhoneTransaction from './transactions/PhoneTransaction.js';\nimport BaseTransaction from './transactions/Base.js';\nimport AuthApiError from '../errors/AuthApiError.js';\nimport AuthSdkError from '../errors/AuthSdkError.js';\nimport { httpRequest } from '../http/request.js';\nimport 'tiny-emitter';\nimport 'js-cookie';\nimport 'cross-fetch';\n\nconst parseInsufficientAuthenticationError = header => {\n  if (!header) {\n    throw new AuthSdkError('Missing header string');\n  }\n\n  return header.split(',').map(part => part.trim()).map(part => part.split('=')).reduce((acc, curr) => {\n    acc[curr[0]] = curr[1].replace(/^\"(.*)\"$/, '$1');\n    return acc;\n  }, {});\n};\n\nfunction sendRequest(_x, _x2) {\n  return _sendRequest.apply(this, arguments);\n}\n\nfunction _sendRequest() {\n  _sendRequest = _asyncToGenerator(function* (oktaAuth, options) {\n    var _a, _b;\n\n    const {\n      accessToken: accessTokenObj,\n      idToken: idTokenObj\n    } = oktaAuth.tokenManager.getTokensSync();\n    const idToken = idTokenObj === null || idTokenObj === void 0 ? void 0 : idTokenObj.idToken;\n    const accessToken = options.accessToken || (accessTokenObj === null || accessTokenObj === void 0 ? void 0 : accessTokenObj.accessToken);\n    const {\n      issuer\n    } = oktaAuth.options;\n    const {\n      url,\n      method,\n      payload\n    } = options;\n    const requestUrl = url.startsWith(issuer) ? url : `${issuer}${url}`;\n\n    if (!accessToken) {\n      throw new AuthSdkError('AccessToken is required to request MyAccount API endpoints.');\n    }\n\n    let res;\n\n    try {\n      res = yield httpRequest(oktaAuth, Object.assign({\n        headers: {\n          'Accept': '*/*;okta-version=1.0.0'\n        },\n        accessToken,\n        url: requestUrl,\n        method\n      }, payload && {\n        args: payload\n      }));\n    } catch (err) {\n      const errorResp = err.xhr;\n\n      if (idToken && (errorResp === null || errorResp === void 0 ? void 0 : errorResp.status) === 403 && !!((_a = errorResp === null || errorResp === void 0 ? void 0 : errorResp.headers) === null || _a === void 0 ? void 0 : _a['www-authenticate'])) {\n        const {\n          error,\n          error_description,\n          max_age\n        } = parseInsufficientAuthenticationError((_b = errorResp === null || errorResp === void 0 ? void 0 : errorResp.headers) === null || _b === void 0 ? void 0 : _b['www-authenticate']);\n\n        if (error === 'insufficient_authentication_context') {\n          const insufficientAuthenticationError = new AuthApiError({\n            errorSummary: error,\n            errorCauses: [{\n              errorSummary: error_description\n            }]\n          }, errorResp, {\n            max_age: +max_age\n          });\n          throw insufficientAuthenticationError;\n        } else {\n          throw err;\n        }\n      } else {\n        throw err;\n      }\n    }\n\n    const map = {\n      EmailTransaction,\n      EmailStatusTransaction,\n      EmailChallengeTransaction,\n      ProfileTransaction,\n      ProfileSchemaTransaction,\n      PhoneTransaction\n    };\n    const TransactionClass = map[options.transactionClassName] || BaseTransaction;\n\n    if (Array.isArray(res)) {\n      return res.map(item => new TransactionClass(oktaAuth, {\n        res: item,\n        accessToken\n      }));\n    }\n\n    return new TransactionClass(oktaAuth, {\n      res,\n      accessToken\n    });\n  });\n  return _sendRequest.apply(this, arguments);\n}\n\nfunction generateRequestFnFromLinks({\n  oktaAuth,\n  accessToken,\n  methodName,\n  links,\n  transactionClassName\n}) {\n  for (const method of ['GET', 'POST', 'PUT', 'DELETE']) {\n    if (method.toLowerCase() === methodName) {\n      const link = links.self;\n      return /*#__PURE__*/function () {\n        var _ref = _asyncToGenerator(function* (payload) {\n          return sendRequest(oktaAuth, {\n            accessToken,\n            url: link.href,\n            method,\n            payload,\n            transactionClassName\n          });\n        });\n\n        return function (_x3) {\n          return _ref.apply(this, arguments);\n        };\n      }();\n    }\n  }\n\n  const link = links[methodName];\n\n  if (!link) {\n    throw new AuthSdkError(`No link is found with methodName: ${methodName}`);\n  }\n\n  return /*#__PURE__*/function () {\n    var _ref2 = _asyncToGenerator(function* (payload) {\n      return sendRequest(oktaAuth, {\n        accessToken,\n        url: link.href,\n        method: link.hints.allow[0],\n        payload,\n        transactionClassName\n      });\n    });\n\n    return function (_x4) {\n      return _ref2.apply(this, arguments);\n    };\n  }();\n}\n\nexport { generateRequestFnFromLinks, sendRequest }; //# sourceMappingURL=request.js.map","map":null,"metadata":{},"sourceType":"module"}