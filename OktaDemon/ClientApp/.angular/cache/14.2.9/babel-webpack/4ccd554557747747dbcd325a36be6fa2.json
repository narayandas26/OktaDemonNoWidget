{"ast":null,"code":"import _asyncToGenerator from \"C:/Users/Narean/source/repos/OktaDemon/OktaDemon/ClientApp/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\n\n/*!\n * Copyright (c) 2015-present, Okta, Inc. and/or its affiliates. All rights reserved.\n * The Okta software accompanied by this notice is provided pursuant to the Apache License, Version 2.0 (the \"License.\")\n *\n * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0.\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * \n * See the License for the specific language governing permissions and limitations under the License.\n */\nimport { removeNils, clone } from '../util/object.js';\nimport AuthSdkError from '../errors/AuthSdkError.js';\nimport { isLocalhost, isIE11OrLess } from '../features.js';\nimport { REFRESH_TOKEN_STORAGE_KEY, TOKEN_STORAGE_NAME } from '../constants.js';\nimport 'tiny-emitter';\nimport 'js-cookie';\nimport 'cross-fetch';\nimport { validateToken } from './util/validateToken.js';\nimport SdkClock from '../clock.js';\nimport { isRefreshToken, isAccessToken, isIDToken } from './types/Token.js';\nimport { EVENT_EXPIRED, EVENT_RENEWED, EVENT_ADDED, EVENT_REMOVED, EVENT_ERROR, EVENT_SET_STORAGE } from './types/TokenManager.js';\nconst DEFAULT_OPTIONS = {\n  autoRenew: true,\n  autoRemove: true,\n  syncStorage: true,\n  clearPendingRemoveTokens: true,\n  storage: undefined,\n  expireEarlySeconds: 30,\n  storageKey: TOKEN_STORAGE_NAME\n};\n\nfunction defaultState() {\n  return {\n    expireTimeouts: {},\n    renewPromise: null\n  };\n}\n\nclass TokenManager {\n  constructor(sdk, options = {}) {\n    this.sdk = sdk;\n    this.emitter = sdk.emitter;\n\n    if (!this.emitter) {\n      throw new AuthSdkError('Emitter should be initialized before TokenManager');\n    }\n\n    options = Object.assign({}, DEFAULT_OPTIONS, removeNils(options));\n\n    if (!isLocalhost()) {\n      options.expireEarlySeconds = DEFAULT_OPTIONS.expireEarlySeconds;\n    }\n\n    this.options = options;\n    const storageOptions = removeNils({\n      storageKey: options.storageKey,\n      secure: options.secure\n    });\n\n    if (typeof options.storage === 'object') {\n      storageOptions.storageProvider = options.storage;\n    } else if (options.storage) {\n      storageOptions.storageType = options.storage;\n    }\n\n    this.storage = sdk.storageManager.getTokenStorage(Object.assign(Object.assign({}, storageOptions), {\n      useSeparateCookies: true\n    }));\n    this.clock = SdkClock.create();\n    this.state = defaultState();\n  }\n\n  on(event, handler, context) {\n    if (context) {\n      this.emitter.on(event, handler, context);\n    } else {\n      this.emitter.on(event, handler);\n    }\n  }\n\n  off(event, handler) {\n    if (handler) {\n      this.emitter.off(event, handler);\n    } else {\n      this.emitter.off(event);\n    }\n  }\n\n  start() {\n    if (this.options.clearPendingRemoveTokens) {\n      this.clearPendingRemoveTokens();\n    }\n\n    this.setExpireEventTimeoutAll();\n  }\n\n  stop() {\n    this.clearExpireEventTimeoutAll();\n  }\n\n  getOptions() {\n    return clone(this.options);\n  }\n\n  getExpireTime(token) {\n    const expireEarlySeconds = this.options.expireEarlySeconds || 0;\n    var expireTime = token.expiresAt - expireEarlySeconds;\n    return expireTime;\n  }\n\n  hasExpired(token) {\n    var expireTime = this.getExpireTime(token);\n    return expireTime <= this.clock.now();\n  }\n\n  emitExpired(key, token) {\n    this.emitter.emit(EVENT_EXPIRED, key, token);\n  }\n\n  emitRenewed(key, freshToken, oldToken) {\n    this.emitter.emit(EVENT_RENEWED, key, freshToken, oldToken);\n  }\n\n  emitAdded(key, token) {\n    this.emitter.emit(EVENT_ADDED, key, token);\n  }\n\n  emitRemoved(key, token) {\n    this.emitter.emit(EVENT_REMOVED, key, token);\n  }\n\n  emitError(error) {\n    this.emitter.emit(EVENT_ERROR, error);\n  }\n\n  clearExpireEventTimeout(key) {\n    clearTimeout(this.state.expireTimeouts[key]);\n    delete this.state.expireTimeouts[key];\n    this.state.renewPromise = null;\n  }\n\n  clearExpireEventTimeoutAll() {\n    var expireTimeouts = this.state.expireTimeouts;\n\n    for (var key in expireTimeouts) {\n      if (!Object.prototype.hasOwnProperty.call(expireTimeouts, key)) {\n        continue;\n      }\n\n      this.clearExpireEventTimeout(key);\n    }\n  }\n\n  setExpireEventTimeout(key, token) {\n    if (isRefreshToken(token)) {\n      return;\n    }\n\n    var expireTime = this.getExpireTime(token);\n    var expireEventWait = Math.max(expireTime - this.clock.now(), 0) * 1000;\n    this.clearExpireEventTimeout(key);\n    var expireEventTimeout = setTimeout(() => {\n      this.emitExpired(key, token);\n    }, expireEventWait);\n    this.state.expireTimeouts[key] = expireEventTimeout;\n  }\n\n  setExpireEventTimeoutAll() {\n    var tokenStorage = this.storage.getStorage();\n\n    for (var key in tokenStorage) {\n      if (!Object.prototype.hasOwnProperty.call(tokenStorage, key)) {\n        continue;\n      }\n\n      var token = tokenStorage[key];\n      this.setExpireEventTimeout(key, token);\n    }\n  }\n\n  resetExpireEventTimeoutAll() {\n    this.clearExpireEventTimeoutAll();\n    this.setExpireEventTimeoutAll();\n  }\n\n  add(key, token) {\n    var tokenStorage = this.storage.getStorage();\n    validateToken(token);\n    tokenStorage[key] = token;\n    this.storage.setStorage(tokenStorage);\n    this.emitSetStorageEvent();\n    this.emitAdded(key, token);\n    this.setExpireEventTimeout(key, token);\n  }\n\n  getSync(key) {\n    var tokenStorage = this.storage.getStorage();\n    return tokenStorage[key];\n  }\n\n  get(key) {\n    var _this = this;\n\n    return _asyncToGenerator(function* () {\n      return _this.getSync(key);\n    })();\n  }\n\n  getTokensSync() {\n    const tokens = {};\n    const tokenStorage = this.storage.getStorage();\n    Object.keys(tokenStorage).forEach(key => {\n      const token = tokenStorage[key];\n\n      if (isAccessToken(token)) {\n        tokens.accessToken = token;\n      } else if (isIDToken(token)) {\n        tokens.idToken = token;\n      } else if (isRefreshToken(token)) {\n        tokens.refreshToken = token;\n      }\n    });\n    return tokens;\n  }\n\n  getTokens() {\n    var _this2 = this;\n\n    return _asyncToGenerator(function* () {\n      return _this2.getTokensSync();\n    })();\n  }\n\n  getStorageKeyByType(type) {\n    const tokenStorage = this.storage.getStorage();\n    const key = Object.keys(tokenStorage).filter(key => {\n      const token = tokenStorage[key];\n      return isAccessToken(token) && type === 'accessToken' || isIDToken(token) && type === 'idToken' || isRefreshToken(token) && type === 'refreshToken';\n    })[0];\n    return key;\n  }\n\n  getTokenType(token) {\n    if (isAccessToken(token)) {\n      return 'accessToken';\n    }\n\n    if (isIDToken(token)) {\n      return 'idToken';\n    }\n\n    if (isRefreshToken(token)) {\n      return 'refreshToken';\n    }\n\n    throw new AuthSdkError('Unknown token type');\n  }\n\n  emitSetStorageEvent() {\n    if (isIE11OrLess()) {\n      const storage = this.storage.getStorage();\n      this.emitter.emit(EVENT_SET_STORAGE, storage);\n    }\n  }\n\n  getStorage() {\n    return this.storage;\n  }\n\n  setTokens(tokens, accessTokenCb, idTokenCb, refreshTokenCb) {\n    const handleTokenCallback = (key, token) => {\n      const type = this.getTokenType(token);\n\n      if (type === 'accessToken') {\n        accessTokenCb && accessTokenCb(key, token);\n      } else if (type === 'idToken') {\n        idTokenCb && idTokenCb(key, token);\n      } else if (type === 'refreshToken') {\n        refreshTokenCb && refreshTokenCb(key, token);\n      }\n    };\n\n    const handleAdded = (key, token) => {\n      this.emitAdded(key, token);\n      this.setExpireEventTimeout(key, token);\n      handleTokenCallback(key, token);\n    };\n\n    const handleRenewed = (key, token, oldToken) => {\n      this.emitRenewed(key, token, oldToken);\n      this.clearExpireEventTimeout(key);\n      this.setExpireEventTimeout(key, token);\n      handleTokenCallback(key, token);\n    };\n\n    const handleRemoved = (key, token) => {\n      this.clearExpireEventTimeout(key);\n      this.emitRemoved(key, token);\n      handleTokenCallback(key, token);\n    };\n\n    const types = ['idToken', 'accessToken', 'refreshToken'];\n    const existingTokens = this.getTokensSync();\n    types.forEach(type => {\n      const token = tokens[type];\n\n      if (token) {\n        validateToken(token, type);\n      }\n    });\n    const storage = types.reduce((storage, type) => {\n      const token = tokens[type];\n\n      if (token) {\n        const storageKey = this.getStorageKeyByType(type) || type;\n        storage[storageKey] = token;\n      }\n\n      return storage;\n    }, {});\n    this.storage.setStorage(storage);\n    this.emitSetStorageEvent();\n    types.forEach(type => {\n      const newToken = tokens[type];\n      const existingToken = existingTokens[type];\n      const storageKey = this.getStorageKeyByType(type) || type;\n\n      if (newToken && existingToken) {\n        handleRemoved(storageKey, existingToken);\n        handleAdded(storageKey, newToken);\n        handleRenewed(storageKey, newToken, existingToken);\n      } else if (newToken) {\n        handleAdded(storageKey, newToken);\n      } else if (existingToken) {\n        handleRemoved(storageKey, existingToken);\n      }\n    });\n  }\n\n  remove(key) {\n    this.clearExpireEventTimeout(key);\n    var tokenStorage = this.storage.getStorage();\n    var removedToken = tokenStorage[key];\n    delete tokenStorage[key];\n    this.storage.setStorage(tokenStorage);\n    this.emitSetStorageEvent();\n    this.emitRemoved(key, removedToken);\n  }\n\n  renewToken(token) {\n    var _this3 = this;\n\n    return _asyncToGenerator(function* () {\n      var _a;\n\n      return (_a = _this3.sdk.token) === null || _a === void 0 ? void 0 : _a.renew(token);\n    })();\n  }\n\n  validateToken(token) {\n    return validateToken(token);\n  }\n\n  renew(key) {\n    if (this.state.renewPromise) {\n      return this.state.renewPromise;\n    }\n\n    try {\n      var token = this.getSync(key);\n\n      if (!token) {\n        throw new AuthSdkError('The tokenManager has no token for the key: ' + key);\n      }\n    } catch (e) {\n      return Promise.reject(e);\n    }\n\n    this.clearExpireEventTimeout(key);\n    const renewPromise = this.state.renewPromise = this.sdk.token.renewTokens().then(tokens => {\n      this.setTokens(tokens);\n      const tokenType = this.getTokenType(token);\n      return tokens[tokenType];\n    }).catch(err => {\n      this.remove(key);\n      err.tokenKey = key;\n      this.emitError(err);\n      throw err;\n    }).finally(() => {\n      this.state.renewPromise = null;\n    });\n    return renewPromise;\n  }\n\n  clear() {\n    const tokens = this.getTokensSync();\n    this.clearExpireEventTimeoutAll();\n    this.storage.clearStorage();\n    this.emitSetStorageEvent();\n    Object.keys(tokens).forEach(key => {\n      this.emitRemoved(key, tokens[key]);\n    });\n  }\n\n  clearPendingRemoveTokens() {\n    const tokenStorage = this.storage.getStorage();\n    const removedTokens = {};\n    Object.keys(tokenStorage).forEach(key => {\n      if (tokenStorage[key].pendingRemove) {\n        removedTokens[key] = tokenStorage[key];\n        delete tokenStorage[key];\n      }\n    });\n    this.storage.setStorage(tokenStorage);\n    this.emitSetStorageEvent();\n    Object.keys(removedTokens).forEach(key => {\n      this.clearExpireEventTimeout(key);\n      this.emitRemoved(key, removedTokens[key]);\n    });\n  }\n\n  updateRefreshToken(token) {\n    const key = this.getStorageKeyByType('refreshToken') || REFRESH_TOKEN_STORAGE_KEY;\n    var tokenStorage = this.storage.getStorage();\n    validateToken(token);\n    tokenStorage[key] = token;\n    this.storage.setStorage(tokenStorage);\n    this.emitSetStorageEvent();\n  }\n\n  removeRefreshToken() {\n    const key = this.getStorageKeyByType('refreshToken') || REFRESH_TOKEN_STORAGE_KEY;\n    this.remove(key);\n  }\n\n  addPendingRemoveFlags() {\n    const tokens = this.getTokensSync();\n    Object.keys(tokens).forEach(key => {\n      tokens[key].pendingRemove = true;\n    });\n    this.setTokens(tokens);\n  }\n\n}\n\nexport { TokenManager }; //# sourceMappingURL=TokenManager.js.map","map":null,"metadata":{},"sourceType":"module"}