{"ast":null,"code":"import _asyncToGenerator from \"C:/Users/Narean/source/repos/OktaDemon/OktaDemon/ClientApp/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\n\n/*!\n * Copyright (c) 2015-present, Okta, Inc. and/or its affiliates. All rights reserved.\n * The Okta software accompanied by this notice is provided pursuant to the Apache License, Version 2.0 (the \"License.\")\n *\n * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0.\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * \n * See the License for the specific language governing permissions and limitations under the License.\n */\nimport AuthSdkError from '../errors/AuthSdkError.js';\nimport { getRemediator, handleFailedResponse, isTerminalResponse, filterValuesForRemediation, getNextStep } from './util.js';\n\nfunction getActionFromValues(values, idxResponse) {\n  return Object.keys(idxResponse.actions).find(action => !!values.resend && action.includes('-resend'));\n}\n\nfunction removeActionFromValues(values) {\n  return Object.assign(Object.assign({}, values), {\n    resend: undefined\n  });\n}\n\nfunction removeActionFromOptions(options, actionName) {\n  let actions = options.actions || [];\n  actions = actions.filter(entry => {\n    if (typeof entry === 'string') {\n      return entry !== actionName;\n    }\n\n    return entry.name !== actionName;\n  });\n  return Object.assign(Object.assign({}, options), {\n    actions\n  });\n}\n\nfunction remediate(_x, _x2, _x3, _x4) {\n  return _remediate.apply(this, arguments);\n}\n\nfunction _remediate() {\n  _remediate = _asyncToGenerator(function* (authClient, idxResponse, values, options) {\n    let {\n      neededToProceed,\n      interactionCode\n    } = idxResponse;\n    const {\n      flow\n    } = options;\n\n    if (interactionCode) {\n      return {\n        idxResponse\n      };\n    }\n\n    const remediator = getRemediator(neededToProceed, values, options);\n    const actionFromValues = getActionFromValues(values, idxResponse);\n    const actionFromOptions = options.actions || [];\n    const actions = [...actionFromOptions, ...(actionFromValues && [actionFromValues] || [])];\n\n    if (actions) {\n      for (let action of actions) {\n        let params = {};\n\n        if (typeof action !== 'string') {\n          params = action.params || {};\n          action = action.name;\n        }\n\n        let valuesWithoutExecutedAction = removeActionFromValues(values);\n        let optionsWithoutExecutedAction = removeActionFromOptions(options, action);\n\n        if (typeof idxResponse.actions[action] === 'function') {\n          idxResponse = yield idxResponse.actions[action](params);\n\n          if (idxResponse.requestDidSucceed === false) {\n            return handleFailedResponse(authClient, idxResponse, options);\n          }\n\n          if (action === 'cancel') {\n            return {\n              idxResponse,\n              canceled: true\n            };\n          }\n\n          return remediate(authClient, idxResponse, valuesWithoutExecutedAction, optionsWithoutExecutedAction);\n        }\n\n        const remediationAction = neededToProceed.find(({\n          name\n        }) => name === action);\n\n        if (remediationAction) {\n          idxResponse = yield idxResponse.proceed(action, params);\n\n          if (idxResponse.requestDidSucceed === false) {\n            return handleFailedResponse(authClient, idxResponse, options);\n          }\n\n          return remediate(authClient, idxResponse, values, optionsWithoutExecutedAction);\n        }\n      }\n    }\n\n    const terminal = isTerminalResponse(idxResponse);\n\n    if (terminal) {\n      return {\n        idxResponse,\n        terminal\n      };\n    }\n\n    if (!remediator) {\n      if (options.step) {\n        values = filterValuesForRemediation(idxResponse, options.step, values);\n        idxResponse = yield idxResponse.proceed(options.step, values);\n\n        if (idxResponse.requestDidSucceed === false) {\n          return handleFailedResponse(authClient, idxResponse, options);\n        }\n\n        return {\n          idxResponse\n        };\n      }\n\n      if (flow === 'default') {\n        return {\n          idxResponse\n        };\n      }\n\n      throw new AuthSdkError(`\n      No remediation can match current flow, check policy settings in your org.\n      Remediations: [${neededToProceed.reduce((acc, curr) => acc ? acc + ' ,' + curr.name : curr.name, '')}]\n    `);\n    }\n\n    if (!remediator.canRemediate()) {\n      const nextStep = getNextStep(authClient, remediator, idxResponse);\n      return {\n        idxResponse,\n        nextStep\n      };\n    }\n\n    const name = remediator.getName();\n    const data = remediator.getData();\n    idxResponse = yield idxResponse.proceed(name, data);\n\n    if (idxResponse.requestDidSucceed === false) {\n      return handleFailedResponse(authClient, idxResponse, options);\n    }\n\n    values = remediator.getValuesAfterProceed();\n    options = Object.assign(Object.assign({}, options), {\n      step: undefined\n    });\n\n    if (options.useGenericRemediator && !idxResponse.interactionCode && !isTerminalResponse(idxResponse)) {\n      const gr = getRemediator(idxResponse.neededToProceed, values, options);\n      const nextStep = getNextStep(authClient, gr, idxResponse);\n      return {\n        idxResponse,\n        nextStep\n      };\n    }\n\n    return remediate(authClient, idxResponse, values, options);\n  });\n  return _remediate.apply(this, arguments);\n}\n\nexport { remediate }; //# sourceMappingURL=remediate.js.map","map":null,"metadata":{},"sourceType":"module"}