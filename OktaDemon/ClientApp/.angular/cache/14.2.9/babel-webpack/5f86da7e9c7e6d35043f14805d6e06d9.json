{"ast":null,"code":"import _asyncToGenerator from \"C:/Users/Narean/source/repos/OktaDemon/OktaDemon/ClientApp/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\n\n/*!\n * Copyright (c) 2015-present, Okta, Inc. and/or its affiliates. All rights reserved.\n * The Okta software accompanied by this notice is provided pursuant to the Apache License, Version 2.0 (the \"License.\")\n *\n * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0.\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * \n * See the License for the specific language governing permissions and limitations under the License.\n */\nimport { __rest } from '../../_virtual/_tslib.js';\nimport * as index from '../../crypto/index.js';\nimport { httpRequest } from '../../http/request.js';\nimport { PromiseQueue } from '../../util/PromiseQueue.js';\nimport 'tiny-emitter';\nimport 'js-cookie';\nimport 'cross-fetch';\nimport PKCE from '../util/pkce.js';\nimport { createTokenAPI } from '../factory/api.js';\nimport { TokenManager } from '../TokenManager.js';\nimport { getOAuthUrls } from '../util/oauth.js';\nimport { isLoginRedirect } from '../util/loginRedirect.js';\nimport { provideOriginalUri } from './browser.js';\n\nfunction mixinOAuth(Base, TransactionManagerConstructor) {\n  var _a;\n\n  const WithOriginalUri = provideOriginalUri(Base);\n  return _a = class OktaAuthOAuth extends WithOriginalUri {\n    constructor(...args) {\n      super(...args);\n      this.transactionManager = new TransactionManagerConstructor(Object.assign({\n        storageManager: this.storageManager\n      }, this.options.transactionManager));\n      this.pkce = {\n        DEFAULT_CODE_CHALLENGE_METHOD: PKCE.DEFAULT_CODE_CHALLENGE_METHOD,\n        generateVerifier: PKCE.generateVerifier,\n        computeChallenge: PKCE.computeChallenge\n      };\n      this._pending = {\n        handleLogin: false\n      };\n      this._tokenQueue = new PromiseQueue();\n      this.token = createTokenAPI(this, this._tokenQueue);\n      this.tokenManager = new TokenManager(this, this.options.tokenManager);\n    }\n\n    clearStorage() {\n      super.clearStorage();\n      this.tokenManager.clear();\n    }\n\n    isAuthenticated(options = {}) {\n      var _this = this;\n\n      return _asyncToGenerator(function* () {\n        const {\n          autoRenew,\n          autoRemove\n        } = _this.tokenManager.getOptions();\n\n        const shouldRenew = options.onExpiredToken ? options.onExpiredToken === 'renew' : autoRenew;\n        const shouldRemove = options.onExpiredToken ? options.onExpiredToken === 'remove' : autoRemove;\n\n        let {\n          accessToken\n        } = _this.tokenManager.getTokensSync();\n\n        if (accessToken && _this.tokenManager.hasExpired(accessToken)) {\n          accessToken = undefined;\n\n          if (shouldRenew) {\n            try {\n              accessToken = yield _this.tokenManager.renew('accessToken');\n            } catch (_a) {}\n          } else if (shouldRemove) {\n            _this.tokenManager.remove('accessToken');\n          }\n        }\n\n        let {\n          idToken\n        } = _this.tokenManager.getTokensSync();\n\n        if (idToken && _this.tokenManager.hasExpired(idToken)) {\n          idToken = undefined;\n\n          if (shouldRenew) {\n            try {\n              idToken = yield _this.tokenManager.renew('idToken');\n            } catch (_b) {}\n          } else if (shouldRemove) {\n            _this.tokenManager.remove('idToken');\n          }\n        }\n\n        return !!(accessToken && idToken);\n      })();\n    }\n\n    signInWithRedirect(opts = {}) {\n      var _this2 = this;\n\n      return _asyncToGenerator(function* () {\n        const {\n          originalUri\n        } = opts,\n              additionalParams = __rest(opts, [\"originalUri\"]);\n\n        if (_this2._pending.handleLogin) {\n          return;\n        }\n\n        _this2._pending.handleLogin = true;\n\n        try {\n          if (originalUri) {\n            _this2.setOriginalUri(originalUri);\n          }\n\n          const params = Object.assign({\n            scopes: _this2.options.scopes || ['openid', 'email', 'profile']\n          }, additionalParams);\n          yield _this2.token.getWithRedirect(params);\n        } finally {\n          _this2._pending.handleLogin = false;\n        }\n      })();\n    }\n\n    getUser() {\n      var _this3 = this;\n\n      return _asyncToGenerator(function* () {\n        const {\n          idToken,\n          accessToken\n        } = _this3.tokenManager.getTokensSync();\n\n        return _this3.token.getUserInfo(accessToken, idToken);\n      })();\n    }\n\n    getIdToken() {\n      const {\n        idToken\n      } = this.tokenManager.getTokensSync();\n      return idToken ? idToken.idToken : undefined;\n    }\n\n    getAccessToken() {\n      const {\n        accessToken\n      } = this.tokenManager.getTokensSync();\n      return accessToken ? accessToken.accessToken : undefined;\n    }\n\n    getRefreshToken() {\n      const {\n        refreshToken\n      } = this.tokenManager.getTokensSync();\n      return refreshToken ? refreshToken.refreshToken : undefined;\n    }\n\n    storeTokensFromRedirect() {\n      var _this4 = this;\n\n      return _asyncToGenerator(function* () {\n        const {\n          tokens\n        } = yield _this4.token.parseFromUrl();\n\n        _this4.tokenManager.setTokens(tokens);\n      })();\n    }\n\n    isLoginRedirect() {\n      return isLoginRedirect(this);\n    }\n\n    isPKCE() {\n      return !!this.options.pkce;\n    }\n\n    hasResponseType(responseType) {\n      let hasResponseType = false;\n\n      if (Array.isArray(this.options.responseType) && this.options.responseType.length) {\n        hasResponseType = this.options.responseType.indexOf(responseType) >= 0;\n      } else {\n        hasResponseType = this.options.responseType === responseType;\n      }\n\n      return hasResponseType;\n    }\n\n    isAuthorizationCodeFlow() {\n      return this.hasResponseType('code');\n    }\n\n    invokeApiMethod(options) {\n      var _this5 = this;\n\n      return _asyncToGenerator(function* () {\n        if (!options.accessToken) {\n          const accessToken = (yield _this5.tokenManager.getTokens()).accessToken;\n          options.accessToken = accessToken === null || accessToken === void 0 ? void 0 : accessToken.accessToken;\n        }\n\n        return httpRequest(_this5, options);\n      })();\n    }\n\n    revokeAccessToken(accessToken) {\n      var _this6 = this;\n\n      return _asyncToGenerator(function* () {\n        if (!accessToken) {\n          accessToken = (yield _this6.tokenManager.getTokens()).accessToken;\n\n          const accessTokenKey = _this6.tokenManager.getStorageKeyByType('accessToken');\n\n          _this6.tokenManager.remove(accessTokenKey);\n        }\n\n        if (!accessToken) {\n          return Promise.resolve(null);\n        }\n\n        return _this6.token.revoke(accessToken);\n      })();\n    }\n\n    revokeRefreshToken(refreshToken) {\n      var _this7 = this;\n\n      return _asyncToGenerator(function* () {\n        if (!refreshToken) {\n          refreshToken = (yield _this7.tokenManager.getTokens()).refreshToken;\n\n          const refreshTokenKey = _this7.tokenManager.getStorageKeyByType('refreshToken');\n\n          _this7.tokenManager.remove(refreshTokenKey);\n        }\n\n        if (!refreshToken) {\n          return Promise.resolve(null);\n        }\n\n        return _this7.token.revoke(refreshToken);\n      })();\n    }\n\n    getSignOutRedirectUrl(options = {}) {\n      let {\n        idToken,\n        postLogoutRedirectUri,\n        state\n      } = options;\n\n      if (!idToken) {\n        idToken = this.tokenManager.getTokensSync().idToken;\n      }\n\n      if (!idToken) {\n        return '';\n      }\n\n      if (!postLogoutRedirectUri) {\n        postLogoutRedirectUri = this.options.postLogoutRedirectUri;\n      }\n\n      const logoutUrl = getOAuthUrls(this).logoutUrl;\n      const idTokenHint = idToken.idToken;\n      let logoutUri = logoutUrl + '?id_token_hint=' + encodeURIComponent(idTokenHint);\n\n      if (postLogoutRedirectUri) {\n        logoutUri += '&post_logout_redirect_uri=' + encodeURIComponent(postLogoutRedirectUri);\n      }\n\n      if (state) {\n        logoutUri += '&state=' + encodeURIComponent(state);\n      }\n\n      return logoutUri;\n    }\n\n    signOut(options) {\n      var _this8 = this;\n\n      return _asyncToGenerator(function* () {\n        options = Object.assign({}, options);\n        var defaultUri = window.location.origin;\n        var currentUri = window.location.href;\n        var postLogoutRedirectUri = options.postLogoutRedirectUri || _this8.options.postLogoutRedirectUri || defaultUri;\n        var accessToken = options.accessToken;\n        var refreshToken = options.refreshToken;\n        var revokeAccessToken = options.revokeAccessToken !== false;\n        var revokeRefreshToken = options.revokeRefreshToken !== false;\n\n        if (revokeRefreshToken && typeof refreshToken === 'undefined') {\n          refreshToken = _this8.tokenManager.getTokensSync().refreshToken;\n        }\n\n        if (revokeAccessToken && typeof accessToken === 'undefined') {\n          accessToken = _this8.tokenManager.getTokensSync().accessToken;\n        }\n\n        if (!options.idToken) {\n          options.idToken = _this8.tokenManager.getTokensSync().idToken;\n        }\n\n        if (revokeRefreshToken && refreshToken) {\n          yield _this8.revokeRefreshToken(refreshToken);\n        }\n\n        if (revokeAccessToken && accessToken) {\n          yield _this8.revokeAccessToken(accessToken);\n        }\n\n        const logoutUri = _this8.getSignOutRedirectUrl(Object.assign(Object.assign({}, options), {\n          postLogoutRedirectUri\n        }));\n\n        if (!logoutUri) {\n          return _this8.closeSession().then(function () {\n            if (postLogoutRedirectUri === currentUri) {\n              window.location.reload();\n            } else {\n              window.location.assign(postLogoutRedirectUri);\n            }\n          });\n        } else {\n          if (options.clearTokensBeforeRedirect) {\n            _this8.tokenManager.clear();\n          } else {\n            _this8.tokenManager.addPendingRemoveFlags();\n          }\n\n          window.location.assign(logoutUri);\n        }\n      })();\n    }\n\n  }, _a.crypto = index, _a;\n}\n\nexport { mixinOAuth }; //# sourceMappingURL=index.js.map","map":null,"metadata":{},"sourceType":"module"}