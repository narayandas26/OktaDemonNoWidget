{"ast":null,"code":"import _asyncToGenerator from \"C:/Users/Narean/source/repos/OktaDemon/OktaDemon/ClientApp/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\n\n/*!\n * Copyright (c) 2015-present, Okta, Inc. and/or its affiliates. All rights reserved.\n * The Okta software accompanied by this notice is provided pursuant to the Apache License, Version 2.0 (the \"License.\")\n *\n * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0.\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * \n * See the License for the specific language governing permissions and limitations under the License.\n */\nimport { AutoRenewService } from '../../services/AutoRenewService.js';\nimport { SyncStorageService } from '../../services/SyncStorageService.js';\nimport { LeaderElectionService } from '../../services/LeaderElectionService.js';\nimport { removeNils } from '../../util/object.js';\nconst AUTO_RENEW = 'autoRenew';\nconst SYNC_STORAGE = 'syncStorage';\nconst LEADER_ELECTION = 'leaderElection';\nlet ServiceManager = /*#__PURE__*/(() => {\n  class ServiceManager {\n    constructor(sdk, options = {}) {\n      this.sdk = sdk;\n      this.onLeader = this.onLeader.bind(this);\n      const {\n        autoRenew,\n        autoRemove,\n        syncStorage\n      } = sdk.tokenManager.getOptions();\n      options.electionChannelName = options.electionChannelName || options.broadcastChannelName;\n      this.options = Object.assign({}, ServiceManager.defaultOptions, {\n        autoRenew,\n        autoRemove,\n        syncStorage\n      }, {\n        electionChannelName: `${sdk.options.clientId}-election`,\n        syncChannelName: `${sdk.options.clientId}-sync`\n      }, removeNils(options));\n      this.started = false;\n      this.services = new Map();\n      ServiceManager.knownServices.forEach(name => {\n        const svc = this.createService(name);\n\n        if (svc) {\n          this.services.set(name, svc);\n        }\n      });\n    }\n\n    onLeader() {\n      var _this = this;\n\n      return _asyncToGenerator(function* () {\n        if (_this.started) {\n          yield _this.startServices();\n        }\n      })();\n    }\n\n    isLeader() {\n      var _a;\n\n      return (_a = this.getService(LEADER_ELECTION)) === null || _a === void 0 ? void 0 : _a.isLeader();\n    }\n\n    isLeaderRequired() {\n      return [...this.services.values()].some(srv => srv.canStart() && srv.requiresLeadership());\n    }\n\n    start() {\n      var _this2 = this;\n\n      return _asyncToGenerator(function* () {\n        if (_this2.started) {\n          return;\n        }\n\n        yield _this2.startServices();\n        _this2.started = true;\n      })();\n    }\n\n    stop() {\n      var _this3 = this;\n\n      return _asyncToGenerator(function* () {\n        yield _this3.stopServices();\n        _this3.started = false;\n      })();\n    }\n\n    getService(name) {\n      return this.services.get(name);\n    }\n\n    startServices() {\n      var _this4 = this;\n\n      return _asyncToGenerator(function* () {\n        for (const [name, srv] of _this4.services.entries()) {\n          if (_this4.canStartService(name, srv)) {\n            yield srv.start();\n          }\n        }\n      })();\n    }\n\n    stopServices() {\n      var _this5 = this;\n\n      return _asyncToGenerator(function* () {\n        for (const srv of _this5.services.values()) {\n          yield srv.stop();\n        }\n      })();\n    }\n\n    canStartService(name, srv) {\n      let canStart = srv.canStart() && !srv.isStarted();\n\n      if (name === LEADER_ELECTION) {\n        canStart && (canStart = this.isLeaderRequired());\n      } else if (srv.requiresLeadership()) {\n        canStart && (canStart = this.isLeader());\n      }\n\n      return canStart;\n    }\n\n    createService(name) {\n      const tokenManager = this.sdk.tokenManager;\n      let service;\n\n      switch (name) {\n        case LEADER_ELECTION:\n          service = new LeaderElectionService(Object.assign(Object.assign({}, this.options), {\n            onLeader: this.onLeader\n          }));\n          break;\n\n        case AUTO_RENEW:\n          service = new AutoRenewService(tokenManager, Object.assign({}, this.options));\n          break;\n\n        case SYNC_STORAGE:\n          service = new SyncStorageService(tokenManager, Object.assign({}, this.options));\n          break;\n\n        default:\n          throw new Error(`Unknown service ${name}`);\n      }\n\n      return service;\n    }\n\n  }\n\n  ServiceManager.knownServices = [AUTO_RENEW, SYNC_STORAGE, LEADER_ELECTION];\n  ServiceManager.defaultOptions = {\n    autoRenew: true,\n    autoRemove: true,\n    syncStorage: true\n  };\n  return ServiceManager;\n})();\nexport { ServiceManager }; //# sourceMappingURL=browser.js.map","map":null,"metadata":{},"sourceType":"module"}