{"ast":null,"code":"import _asyncToGenerator from \"C:/Users/Narean/source/repos/OktaDemon/OktaDemon/ClientApp/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\n\n/*!\n * Copyright (c) 2015-present, Okta, Inc. and/or its affiliates. All rights reserved.\n * The Okta software accompanied by this notice is provided pursuant to the Apache License, Version 2.0 (the \"License.\")\n *\n * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0.\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * \n * See the License for the specific language governing permissions and limitations under the License.\n */\nimport { removeNils, clone } from '../util/object.js';\nimport AuthSdkError from '../errors/AuthSdkError.js';\nimport { isLocalhost, isIE11OrLess } from '../features.js';\nimport { REFRESH_TOKEN_STORAGE_KEY, TOKEN_STORAGE_NAME } from '../constants.js';\nimport 'tiny-emitter';\nimport 'js-cookie';\nimport 'cross-fetch';\nimport { validateToken } from './util/validateToken.js';\nimport SdkClock from '../clock.js';\nimport { isRefreshToken, isAccessToken, isIDToken } from './types/Token.js';\nimport { EVENT_EXPIRED, EVENT_RENEWED, EVENT_ADDED, EVENT_REMOVED, EVENT_ERROR, EVENT_SET_STORAGE } from './types/TokenManager.js';\nconst DEFAULT_OPTIONS = {\n  autoRenew: true,\n  autoRemove: true,\n  syncStorage: true,\n  clearPendingRemoveTokens: true,\n  storage: undefined,\n  expireEarlySeconds: 30,\n  storageKey: TOKEN_STORAGE_NAME\n};\n\nfunction defaultState() {\n  return {\n    expireTimeouts: {},\n    renewPromise: null\n  };\n}\n\nclass TokenManager {\n  constructor(sdk, options = {}) {\n    this.sdk = sdk;\n    this.emitter = sdk.emitter;\n\n    if (!this.emitter) {\n      throw new AuthSdkError('Emitter should be initialized before TokenManager');\n    }\n\n    options = Object.assign({}, DEFAULT_OPTIONS, removeNils(options));\n\n    if (!isLocalhost()) {\n      options.expireEarlySeconds = DEFAULT_OPTIONS.expireEarlySeconds;\n    }\n\n    this.options = options;\n    const storageOptions = removeNils({\n      storageKey: options.storageKey,\n      secure: options.secure\n    });\n\n    if (typeof options.storage === 'object') {\n      storageOptions.storageProvider = options.storage;\n    } else if (options.storage) {\n      storageOptions.storageType = options.storage;\n    }\n\n    this.storage = sdk.storageManager.getTokenStorage(Object.assign(Object.assign({}, storageOptions), {\n      useSeparateCookies: true\n    }));\n    this.clock = SdkClock.create();\n    this.state = defaultState();\n  }\n\n  on(event, handler, context) {\n    if (context) {\n      this.emitter.on(event, handler, context);\n    } else {\n      this.emitter.on(event, handler);\n    }\n  }\n\n  off(event, handler) {\n    if (handler) {\n      this.emitter.off(event, handler);\n    } else {\n      this.emitter.off(event);\n    }\n  }\n\n  start() {\n    if (this.options.clearPendingRemoveTokens) {\n      this.clearPendingRemoveTokens();\n    }\n\n    this.setExpireEventTimeoutAll();\n  }\n\n  stop() {\n    this.clearExpireEventTimeoutAll();\n  }\n\n  getOptions() {\n    return clone(this.options);\n  }\n\n  getExpireTime(token) {\n    const expireEarlySeconds = this.options.expireEarlySeconds || 0;\n    var expireTime = token.expiresAt - expireEarlySeconds;\n    return expireTime;\n  }\n\n  hasExpired(token) {\n    var expireTime = this.getExpireTime(token);\n    return expireTime <= this.clock.now();\n  }\n\n  emitExpired(key, token) {\n    this.emitter.emit(EVENT_EXPIRED, key, token);\n  }\n\n  emitRenewed(key, freshToken, oldToken) {\n    this.emitter.emit(EVENT_RENEWED, key, freshToken, oldToken);\n  }\n\n  emitAdded(key, token) {\n    this.emitter.emit(EVENT_ADDED, key, token);\n  }\n\n  emitRemoved(key, token) {\n    this.emitter.emit(EVENT_REMOVED, key, token);\n  }\n\n  emitError(error) {\n    this.emitter.emit(EVENT_ERROR, error);\n  }\n\n  clearExpireEventTimeout(key) {\n    clearTimeout(this.state.expireTimeouts[key]);\n    delete this.state.expireTimeouts[key];\n    this.state.renewPromise = null;\n  }\n\n  clearExpireEventTimeoutAll() {\n    var expireTimeouts = this.state.expireTimeouts;\n\n    for (var key in expireTimeouts) {\n      if (!Object.prototype.hasOwnProperty.call(expireTimeouts, key)) {\n        continue;\n      }\n\n      this.clearExpireEventTimeout(key);\n    }\n  }\n\n  setExpireEventTimeout(key, token) {\n    if (isRefreshToken(token)) {\n      return;\n    }\n\n    var expireTime = this.getExpireTime(token);\n    var expireEventWait = Math.max(expireTime - this.clock.now(), 0) * 1000;\n    this.clearExpireEventTimeout(key);\n    var expireEventTimeout = setTimeout(() => {\n      this.emitExpired(key, token);\n    }, expireEventWait);\n    this.state.expireTimeouts[key] = expireEventTimeout;\n  }\n\n  setExpireEventTimeoutAll() {\n    var tokenStorage = this.storage.getStorage();\n\n    for (var key in tokenStorage) {\n      if (!Object.prototype.hasOwnProperty.call(tokenStorage, key)) {\n        continue;\n      }\n\n      var token = tokenStorage[key];\n      this.setExpireEventTimeout(key, token);\n    }\n  }\n\n  resetExpireEventTimeoutAll() {\n    this.clearExpireEventTimeoutAll();\n    this.setExpireEventTimeoutAll();\n  }\n\n  add(key, token) {\n    var tokenStorage = this.storage.getStorage();\n    validateToken(token);\n    tokenStorage[key] = token;\n    this.storage.setStorage(tokenStorage);\n    this.emitSetStorageEvent();\n    this.emitAdded(key, token);\n    this.setExpireEventTimeout(key, token);\n  }\n\n  getSync(key) {\n    var tokenStorage = this.storage.getStorage();\n    return tokenStorage[key];\n  }\n\n  get(key) {\n    var _this = this;\n\n    return _asyncToGenerator(function* () {\n      return _this.getSync(key);\n    })();\n  }\n\n  getTokensSync() {\n    const tokens = {};\n    const tokenStorage = this.storage.getStorage();\n    Object.keys(tokenStorage).forEach(key => {\n      const token = tokenStorage[key];\n\n      if (isAccessToken(token)) {\n        tokens.accessToken = token;\n      } else if (isIDToken(token)) {\n        tokens.idToken = token;\n      } else if (isRefreshToken(token)) {\n        tokens.refreshToken = token;\n      }\n    });\n    return tokens;\n  }\n\n  getTokens() {\n    var _this2 = this;\n\n    return _asyncToGenerator(function* () {\n      return _this2.getTokensSync();\n    })();\n  }\n\n  getStorageKeyByType(type) {\n    const tokenStorage = this.storage.getStorage();\n    const key = Object.keys(tokenStorage).filter(key => {\n      const token = tokenStorage[key];\n      return isAccessToken(token) && type === 'accessToken' || isIDToken(token) && type === 'idToken' || isRefreshToken(token) && type === 'refreshToken';\n    })[0];\n    return key;\n  }\n\n  getTokenType(token) {\n    if (isAccessToken(token)) {\n      return 'accessToken';\n    }\n\n    if (isIDToken(token)) {\n      return 'idToken';\n    }\n\n    if (isRefreshToken(token)) {\n      return 'refreshToken';\n    }\n\n    throw new AuthSdkError('Unknown token type');\n  }\n\n  emitSetStorageEvent() {\n    if (isIE11OrLess()) {\n      const storage = this.storage.getStorage();\n      this.emitter.emit(EVENT_SET_STORAGE, storage);\n    }\n  }\n\n  getStorage() {\n    return this.storage;\n  }\n\n  setTokens(tokens, accessTokenCb, idTokenCb, refreshTokenCb) {\n    const handleTokenCallback = (key, token) => {\n      const type = this.getTokenType(token);\n\n      if (type === 'accessToken') {\n        accessTokenCb && accessTokenCb(key, token);\n      } else if (type === 'idToken') {\n        idTokenCb && idTokenCb(key, token);\n      } else if (type === 'refreshToken') {\n        refreshTokenCb && refreshTokenCb(key, token);\n      }\n    };\n\n    const handleAdded = (key, token) => {\n      this.emitAdded(key, token);\n      this.setExpireEventTimeout(key, token);\n      handleTokenCallback(key, token);\n    };\n\n    const handleRenewed = (key, token, oldToken) => {\n      this.emitRenewed(key, token, oldToken);\n      this.clearExpireEventTimeout(key);\n      this.setExpireEventTimeout(key, token);\n      handleTokenCallback(key, token);\n    };\n\n    const handleRemoved = (key, token) => {\n      this.clearExpireEventTimeout(key);\n      this.emitRemoved(key, token);\n      handleTokenCallback(key, token);\n    };\n\n    const types = ['idToken', 'accessToken', 'refreshToken'];\n    const existingTokens = this.getTokensSync();\n    types.forEach(type => {\n      const token = tokens[type];\n\n      if (token) {\n        validateToken(token, type);\n      }\n    });\n    const storage = types.reduce((storage, type) => {\n      const token = tokens[type];\n\n      if (token) {\n        const storageKey = this.getStorageKeyByType(type) || type;\n        storage[storageKey] = token;\n      }\n\n      return storage;\n    }, {});\n    this.storage.setStorage(storage);\n    this.emitSetStorageEvent();\n    types.forEach(type => {\n      const newToken = tokens[type];\n      const existingToken = existingTokens[type];\n      const storageKey = this.getStorageKeyByType(type) || type;\n\n      if (newToken && existingToken) {\n        handleRemoved(storageKey, existingToken);\n        handleAdded(storageKey, newToken);\n        handleRenewed(storageKey, newToken, existingToken);\n      } else if (newToken) {\n        handleAdded(storageKey, newToken);\n      } else if (existingToken) {\n        handleRemoved(storageKey, existingToken);\n      }\n    });\n  }\n\n  remove(key) {\n    this.clearExpireEventTimeout(key);\n    var tokenStorage = this.storage.getStorage();\n    var removedToken = tokenStorage[key];\n    delete tokenStorage[key];\n    this.storage.setStorage(tokenStorage);\n    this.emitSetStorageEvent();\n    this.emitRemoved(key, removedToken);\n  }\n\n  renewToken(token) {\n    var _this3 = this;\n\n    return _asyncToGenerator(function* () {\n      var _a;\n\n      return (_a = _this3.sdk.token) === null || _a === void 0 ? void 0 : _a.renew(token);\n    })();\n  }\n\n  validateToken(token) {\n    return validateToken(token);\n  }\n\n  renew(key) {\n    if (this.state.renewPromise) {\n      return this.state.renewPromise;\n    }\n\n    try {\n      var token = this.getSync(key);\n\n      if (!token) {\n        throw new AuthSdkError('The tokenManager has no token for the key: ' + key);\n      }\n    } catch (e) {\n      return Promise.reject(e);\n    }\n\n    this.clearExpireEventTimeout(key);\n    const renewPromise = this.state.renewPromise = this.sdk.token.renewTokens().then(tokens => {\n      this.setTokens(tokens);\n      const tokenType = this.getTokenType(token);\n      return tokens[tokenType];\n    }).catch(err => {\n      this.remove(key);\n      err.tokenKey = key;\n      this.emitError(err);\n      throw err;\n    }).finally(() => {\n      this.state.renewPromise = null;\n    });\n    return renewPromise;\n  }\n\n  clear() {\n    const tokens = this.getTokensSync();\n    this.clearExpireEventTimeoutAll();\n    this.storage.clearStorage();\n    this.emitSetStorageEvent();\n    Object.keys(tokens).forEach(key => {\n      this.emitRemoved(key, tokens[key]);\n    });\n  }\n\n  clearPendingRemoveTokens() {\n    const tokenStorage = this.storage.getStorage();\n    const removedTokens = {};\n    Object.keys(tokenStorage).forEach(key => {\n      if (tokenStorage[key].pendingRemove) {\n        removedTokens[key] = tokenStorage[key];\n        delete tokenStorage[key];\n      }\n    });\n    this.storage.setStorage(tokenStorage);\n    this.emitSetStorageEvent();\n    Object.keys(removedTokens).forEach(key => {\n      this.clearExpireEventTimeout(key);\n      this.emitRemoved(key, removedTokens[key]);\n    });\n  }\n\n  updateRefreshToken(token) {\n    const key = this.getStorageKeyByType('refreshToken') || REFRESH_TOKEN_STORAGE_KEY;\n    var tokenStorage = this.storage.getStorage();\n    validateToken(token);\n    tokenStorage[key] = token;\n    this.storage.setStorage(tokenStorage);\n    this.emitSetStorageEvent();\n  }\n\n  removeRefreshToken() {\n    const key = this.getStorageKeyByType('refreshToken') || REFRESH_TOKEN_STORAGE_KEY;\n    this.remove(key);\n  }\n\n  addPendingRemoveFlags() {\n    const tokens = this.getTokensSync();\n    Object.keys(tokens).forEach(key => {\n      tokens[key].pendingRemove = true;\n    });\n    this.setTokens(tokens);\n  }\n\n}\n\nexport { TokenManager };","map":{"version":3,"names":["removeNils","clone","AuthSdkError","isLocalhost","isIE11OrLess","REFRESH_TOKEN_STORAGE_KEY","TOKEN_STORAGE_NAME","validateToken","SdkClock","isRefreshToken","isAccessToken","isIDToken","EVENT_EXPIRED","EVENT_RENEWED","EVENT_ADDED","EVENT_REMOVED","EVENT_ERROR","EVENT_SET_STORAGE","DEFAULT_OPTIONS","autoRenew","autoRemove","syncStorage","clearPendingRemoveTokens","storage","undefined","expireEarlySeconds","storageKey","defaultState","expireTimeouts","renewPromise","TokenManager","constructor","sdk","options","emitter","Object","assign","storageOptions","secure","storageProvider","storageType","storageManager","getTokenStorage","useSeparateCookies","clock","create","state","on","event","handler","context","off","start","setExpireEventTimeoutAll","stop","clearExpireEventTimeoutAll","getOptions","getExpireTime","token","expireTime","expiresAt","hasExpired","now","emitExpired","key","emit","emitRenewed","freshToken","oldToken","emitAdded","emitRemoved","emitError","error","clearExpireEventTimeout","clearTimeout","prototype","hasOwnProperty","call","setExpireEventTimeout","expireEventWait","Math","max","expireEventTimeout","setTimeout","tokenStorage","getStorage","resetExpireEventTimeoutAll","add","setStorage","emitSetStorageEvent","getSync","get","getTokensSync","tokens","keys","forEach","accessToken","idToken","refreshToken","getTokens","getStorageKeyByType","type","filter","getTokenType","setTokens","accessTokenCb","idTokenCb","refreshTokenCb","handleTokenCallback","handleAdded","handleRenewed","handleRemoved","types","existingTokens","reduce","newToken","existingToken","remove","removedToken","renewToken","_a","renew","e","Promise","reject","renewTokens","then","tokenType","catch","err","tokenKey","finally","clear","clearStorage","removedTokens","pendingRemove","updateRefreshToken","removeRefreshToken","addPendingRemoveFlags"],"sources":["C:/Users/Narean/source/repos/OktaDemon/OktaDemon/ClientApp/node_modules/@okta/okta-auth-js/esm/browser/oidc/TokenManager.js"],"sourcesContent":["/*!\n * Copyright (c) 2015-present, Okta, Inc. and/or its affiliates. All rights reserved.\n * The Okta software accompanied by this notice is provided pursuant to the Apache License, Version 2.0 (the \"License.\")\n *\n * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0.\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * \n * See the License for the specific language governing permissions and limitations under the License.\n */\n\nimport { removeNils, clone } from '../util/object.js';\nimport AuthSdkError from '../errors/AuthSdkError.js';\nimport { isLocalhost, isIE11OrLess } from '../features.js';\nimport { REFRESH_TOKEN_STORAGE_KEY, TOKEN_STORAGE_NAME } from '../constants.js';\nimport 'tiny-emitter';\nimport 'js-cookie';\nimport 'cross-fetch';\nimport { validateToken } from './util/validateToken.js';\nimport SdkClock from '../clock.js';\nimport { isRefreshToken, isAccessToken, isIDToken } from './types/Token.js';\nimport { EVENT_EXPIRED, EVENT_RENEWED, EVENT_ADDED, EVENT_REMOVED, EVENT_ERROR, EVENT_SET_STORAGE } from './types/TokenManager.js';\n\nconst DEFAULT_OPTIONS = {\n    autoRenew: true,\n    autoRemove: true,\n    syncStorage: true,\n    clearPendingRemoveTokens: true,\n    storage: undefined,\n    expireEarlySeconds: 30,\n    storageKey: TOKEN_STORAGE_NAME\n};\nfunction defaultState() {\n    return {\n        expireTimeouts: {},\n        renewPromise: null\n    };\n}\nclass TokenManager {\n    constructor(sdk, options = {}) {\n        this.sdk = sdk;\n        this.emitter = sdk.emitter;\n        if (!this.emitter) {\n            throw new AuthSdkError('Emitter should be initialized before TokenManager');\n        }\n        options = Object.assign({}, DEFAULT_OPTIONS, removeNils(options));\n        if (!isLocalhost()) {\n            options.expireEarlySeconds = DEFAULT_OPTIONS.expireEarlySeconds;\n        }\n        this.options = options;\n        const storageOptions = removeNils({\n            storageKey: options.storageKey,\n            secure: options.secure,\n        });\n        if (typeof options.storage === 'object') {\n            storageOptions.storageProvider = options.storage;\n        }\n        else if (options.storage) {\n            storageOptions.storageType = options.storage;\n        }\n        this.storage = sdk.storageManager.getTokenStorage(Object.assign(Object.assign({}, storageOptions), { useSeparateCookies: true }));\n        this.clock = SdkClock.create( );\n        this.state = defaultState();\n    }\n    on(event, handler, context) {\n        if (context) {\n            this.emitter.on(event, handler, context);\n        }\n        else {\n            this.emitter.on(event, handler);\n        }\n    }\n    off(event, handler) {\n        if (handler) {\n            this.emitter.off(event, handler);\n        }\n        else {\n            this.emitter.off(event);\n        }\n    }\n    start() {\n        if (this.options.clearPendingRemoveTokens) {\n            this.clearPendingRemoveTokens();\n        }\n        this.setExpireEventTimeoutAll();\n    }\n    stop() {\n        this.clearExpireEventTimeoutAll();\n    }\n    getOptions() {\n        return clone(this.options);\n    }\n    getExpireTime(token) {\n        const expireEarlySeconds = this.options.expireEarlySeconds || 0;\n        var expireTime = token.expiresAt - expireEarlySeconds;\n        return expireTime;\n    }\n    hasExpired(token) {\n        var expireTime = this.getExpireTime(token);\n        return expireTime <= this.clock.now();\n    }\n    emitExpired(key, token) {\n        this.emitter.emit(EVENT_EXPIRED, key, token);\n    }\n    emitRenewed(key, freshToken, oldToken) {\n        this.emitter.emit(EVENT_RENEWED, key, freshToken, oldToken);\n    }\n    emitAdded(key, token) {\n        this.emitter.emit(EVENT_ADDED, key, token);\n    }\n    emitRemoved(key, token) {\n        this.emitter.emit(EVENT_REMOVED, key, token);\n    }\n    emitError(error) {\n        this.emitter.emit(EVENT_ERROR, error);\n    }\n    clearExpireEventTimeout(key) {\n        clearTimeout(this.state.expireTimeouts[key]);\n        delete this.state.expireTimeouts[key];\n        this.state.renewPromise = null;\n    }\n    clearExpireEventTimeoutAll() {\n        var expireTimeouts = this.state.expireTimeouts;\n        for (var key in expireTimeouts) {\n            if (!Object.prototype.hasOwnProperty.call(expireTimeouts, key)) {\n                continue;\n            }\n            this.clearExpireEventTimeout(key);\n        }\n    }\n    setExpireEventTimeout(key, token) {\n        if (isRefreshToken(token)) {\n            return;\n        }\n        var expireTime = this.getExpireTime(token);\n        var expireEventWait = Math.max(expireTime - this.clock.now(), 0) * 1000;\n        this.clearExpireEventTimeout(key);\n        var expireEventTimeout = setTimeout(() => {\n            this.emitExpired(key, token);\n        }, expireEventWait);\n        this.state.expireTimeouts[key] = expireEventTimeout;\n    }\n    setExpireEventTimeoutAll() {\n        var tokenStorage = this.storage.getStorage();\n        for (var key in tokenStorage) {\n            if (!Object.prototype.hasOwnProperty.call(tokenStorage, key)) {\n                continue;\n            }\n            var token = tokenStorage[key];\n            this.setExpireEventTimeout(key, token);\n        }\n    }\n    resetExpireEventTimeoutAll() {\n        this.clearExpireEventTimeoutAll();\n        this.setExpireEventTimeoutAll();\n    }\n    add(key, token) {\n        var tokenStorage = this.storage.getStorage();\n        validateToken(token);\n        tokenStorage[key] = token;\n        this.storage.setStorage(tokenStorage);\n        this.emitSetStorageEvent();\n        this.emitAdded(key, token);\n        this.setExpireEventTimeout(key, token);\n    }\n    getSync(key) {\n        var tokenStorage = this.storage.getStorage();\n        return tokenStorage[key];\n    }\n    async get(key) {\n        return this.getSync(key);\n    }\n    getTokensSync() {\n        const tokens = {};\n        const tokenStorage = this.storage.getStorage();\n        Object.keys(tokenStorage).forEach(key => {\n            const token = tokenStorage[key];\n            if (isAccessToken(token)) {\n                tokens.accessToken = token;\n            }\n            else if (isIDToken(token)) {\n                tokens.idToken = token;\n            }\n            else if (isRefreshToken(token)) {\n                tokens.refreshToken = token;\n            }\n        });\n        return tokens;\n    }\n    async getTokens() {\n        return this.getTokensSync();\n    }\n    getStorageKeyByType(type) {\n        const tokenStorage = this.storage.getStorage();\n        const key = Object.keys(tokenStorage).filter(key => {\n            const token = tokenStorage[key];\n            return (isAccessToken(token) && type === 'accessToken')\n                || (isIDToken(token) && type === 'idToken')\n                || (isRefreshToken(token) && type === 'refreshToken');\n        })[0];\n        return key;\n    }\n    getTokenType(token) {\n        if (isAccessToken(token)) {\n            return 'accessToken';\n        }\n        if (isIDToken(token)) {\n            return 'idToken';\n        }\n        if (isRefreshToken(token)) {\n            return 'refreshToken';\n        }\n        throw new AuthSdkError('Unknown token type');\n    }\n    emitSetStorageEvent() {\n        if (isIE11OrLess()) {\n            const storage = this.storage.getStorage();\n            this.emitter.emit(EVENT_SET_STORAGE, storage);\n        }\n    }\n    getStorage() {\n        return this.storage;\n    }\n    setTokens(tokens,\n    accessTokenCb, idTokenCb, refreshTokenCb) {\n        const handleTokenCallback = (key, token) => {\n            const type = this.getTokenType(token);\n            if (type === 'accessToken') {\n                accessTokenCb && accessTokenCb(key, token);\n            }\n            else if (type === 'idToken') {\n                idTokenCb && idTokenCb(key, token);\n            }\n            else if (type === 'refreshToken') {\n                refreshTokenCb && refreshTokenCb(key, token);\n            }\n        };\n        const handleAdded = (key, token) => {\n            this.emitAdded(key, token);\n            this.setExpireEventTimeout(key, token);\n            handleTokenCallback(key, token);\n        };\n        const handleRenewed = (key, token, oldToken) => {\n            this.emitRenewed(key, token, oldToken);\n            this.clearExpireEventTimeout(key);\n            this.setExpireEventTimeout(key, token);\n            handleTokenCallback(key, token);\n        };\n        const handleRemoved = (key, token) => {\n            this.clearExpireEventTimeout(key);\n            this.emitRemoved(key, token);\n            handleTokenCallback(key, token);\n        };\n        const types = ['idToken', 'accessToken', 'refreshToken'];\n        const existingTokens = this.getTokensSync();\n        types.forEach((type) => {\n            const token = tokens[type];\n            if (token) {\n                validateToken(token, type);\n            }\n        });\n        const storage = types.reduce((storage, type) => {\n            const token = tokens[type];\n            if (token) {\n                const storageKey = this.getStorageKeyByType(type) || type;\n                storage[storageKey] = token;\n            }\n            return storage;\n        }, {});\n        this.storage.setStorage(storage);\n        this.emitSetStorageEvent();\n        types.forEach(type => {\n            const newToken = tokens[type];\n            const existingToken = existingTokens[type];\n            const storageKey = this.getStorageKeyByType(type) || type;\n            if (newToken && existingToken) {\n                handleRemoved(storageKey, existingToken);\n                handleAdded(storageKey, newToken);\n                handleRenewed(storageKey, newToken, existingToken);\n            }\n            else if (newToken) {\n                handleAdded(storageKey, newToken);\n            }\n            else if (existingToken) {\n                handleRemoved(storageKey, existingToken);\n            }\n        });\n    }\n    remove(key) {\n        this.clearExpireEventTimeout(key);\n        var tokenStorage = this.storage.getStorage();\n        var removedToken = tokenStorage[key];\n        delete tokenStorage[key];\n        this.storage.setStorage(tokenStorage);\n        this.emitSetStorageEvent();\n        this.emitRemoved(key, removedToken);\n    }\n    async renewToken(token) {\n        var _a;\n        return (_a = this.sdk.token) === null || _a === void 0 ? void 0 : _a.renew(token);\n    }\n    validateToken(token) {\n        return validateToken(token);\n    }\n    renew(key) {\n        if (this.state.renewPromise) {\n            return this.state.renewPromise;\n        }\n        try {\n            var token = this.getSync(key);\n            if (!token) {\n                throw new AuthSdkError('The tokenManager has no token for the key: ' + key);\n            }\n        }\n        catch (e) {\n            return Promise.reject(e);\n        }\n        this.clearExpireEventTimeout(key);\n        const renewPromise = this.state.renewPromise = this.sdk.token.renewTokens()\n            .then(tokens => {\n            this.setTokens(tokens);\n            const tokenType = this.getTokenType(token);\n            return tokens[tokenType];\n        })\n            .catch(err => {\n            this.remove(key);\n            err.tokenKey = key;\n            this.emitError(err);\n            throw err;\n        })\n            .finally(() => {\n            this.state.renewPromise = null;\n        });\n        return renewPromise;\n    }\n    clear() {\n        const tokens = this.getTokensSync();\n        this.clearExpireEventTimeoutAll();\n        this.storage.clearStorage();\n        this.emitSetStorageEvent();\n        Object.keys(tokens).forEach(key => {\n            this.emitRemoved(key, tokens[key]);\n        });\n    }\n    clearPendingRemoveTokens() {\n        const tokenStorage = this.storage.getStorage();\n        const removedTokens = {};\n        Object.keys(tokenStorage).forEach(key => {\n            if (tokenStorage[key].pendingRemove) {\n                removedTokens[key] = tokenStorage[key];\n                delete tokenStorage[key];\n            }\n        });\n        this.storage.setStorage(tokenStorage);\n        this.emitSetStorageEvent();\n        Object.keys(removedTokens).forEach(key => {\n            this.clearExpireEventTimeout(key);\n            this.emitRemoved(key, removedTokens[key]);\n        });\n    }\n    updateRefreshToken(token) {\n        const key = this.getStorageKeyByType('refreshToken') || REFRESH_TOKEN_STORAGE_KEY;\n        var tokenStorage = this.storage.getStorage();\n        validateToken(token);\n        tokenStorage[key] = token;\n        this.storage.setStorage(tokenStorage);\n        this.emitSetStorageEvent();\n    }\n    removeRefreshToken() {\n        const key = this.getStorageKeyByType('refreshToken') || REFRESH_TOKEN_STORAGE_KEY;\n        this.remove(key);\n    }\n    addPendingRemoveFlags() {\n        const tokens = this.getTokensSync();\n        Object.keys(tokens).forEach(key => {\n            tokens[key].pendingRemove = true;\n        });\n        this.setTokens(tokens);\n    }\n}\n\nexport { TokenManager };\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}