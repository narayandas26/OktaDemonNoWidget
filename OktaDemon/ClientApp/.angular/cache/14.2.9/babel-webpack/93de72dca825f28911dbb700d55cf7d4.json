{"ast":null,"code":"import _asyncToGenerator from \"C:/Users/Narean/source/repos/OktaDemon/OktaDemon/ClientApp/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\n\n/*!\n * Copyright (c) 2015-present, Okta, Inc. and/or its affiliates. All rights reserved.\n * The Okta software accompanied by this notice is provided pursuant to the Apache License, Version 2.0 (the \"License.\")\n *\n * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0.\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * \n * See the License for the specific language governing permissions and limitations under the License.\n */\nimport AuthSdkError from '../errors/AuthSdkError.js';\nimport { isString } from '../util/types.js';\nimport { isInteractionRequiredError } from './util/errors.js';\nimport 'tiny-emitter';\nimport 'js-cookie';\nimport 'cross-fetch';\nimport { urlParamsToObject } from './util/urlParams.js';\nimport { handleOAuthResponse } from './handleOAuthResponse.js';\n\nfunction removeHash(sdk) {\n  var nativeHistory = sdk.token.parseFromUrl._getHistory();\n\n  var nativeDoc = sdk.token.parseFromUrl._getDocument();\n\n  var nativeLoc = sdk.token.parseFromUrl._getLocation();\n\n  if (nativeHistory && nativeHistory.replaceState) {\n    nativeHistory.replaceState(null, nativeDoc.title, nativeLoc.pathname + nativeLoc.search);\n  } else {\n    nativeLoc.hash = '';\n  }\n}\n\nfunction removeSearch(sdk) {\n  var nativeHistory = sdk.token.parseFromUrl._getHistory();\n\n  var nativeDoc = sdk.token.parseFromUrl._getDocument();\n\n  var nativeLoc = sdk.token.parseFromUrl._getLocation();\n\n  if (nativeHistory && nativeHistory.replaceState) {\n    nativeHistory.replaceState(null, nativeDoc.title, nativeLoc.pathname + nativeLoc.hash);\n  } else {\n    nativeLoc.search = '';\n  }\n}\n\nfunction getResponseMode(sdk) {\n  var defaultResponseMode = sdk.options.pkce ? 'query' : 'fragment';\n  var responseMode = sdk.options.responseMode || defaultResponseMode;\n  return responseMode;\n}\n\nfunction parseOAuthResponseFromUrl(sdk, options) {\n  options = options || {};\n\n  if (isString(options)) {\n    options = {\n      url: options\n    };\n  } else {\n    options = options;\n  }\n\n  var url = options.url;\n  var responseMode = options.responseMode || getResponseMode(sdk);\n\n  var nativeLoc = sdk.token.parseFromUrl._getLocation();\n\n  var paramStr;\n\n  if (responseMode === 'query') {\n    paramStr = url ? url.substring(url.indexOf('?')) : nativeLoc.search;\n  } else {\n    paramStr = url ? url.substring(url.indexOf('#')) : nativeLoc.hash;\n  }\n\n  if (!paramStr) {\n    throw new AuthSdkError('Unable to parse a token from the url');\n  }\n\n  return urlParamsToObject(paramStr);\n}\n\nfunction cleanOAuthResponseFromUrl(sdk, options) {\n  const responseMode = options.responseMode || getResponseMode(sdk);\n  responseMode === 'query' ? removeSearch(sdk) : removeHash(sdk);\n}\n\nfunction parseFromUrl(_x, _x2) {\n  return _parseFromUrl.apply(this, arguments);\n}\n\nfunction _parseFromUrl() {\n  _parseFromUrl = _asyncToGenerator(function* (sdk, options) {\n    options = options || {};\n\n    if (isString(options)) {\n      options = {\n        url: options\n      };\n    } else {\n      options = options;\n    }\n\n    const res = parseOAuthResponseFromUrl(sdk, options);\n    const state = res.state;\n    const oauthParams = sdk.transactionManager.load({\n      state\n    });\n\n    if (!oauthParams) {\n      if (sdk.options.pkce) {\n        throw new AuthSdkError('Could not load PKCE codeVerifier from storage. This may indicate the auth flow has already completed or multiple auth flows are executing concurrently.', undefined);\n      }\n\n      throw new AuthSdkError('Unable to retrieve OAuth redirect params from storage');\n    }\n\n    const urls = oauthParams.urls;\n    delete oauthParams.urls;\n\n    if (!options.url) {\n      cleanOAuthResponseFromUrl(sdk, options);\n    }\n\n    return handleOAuthResponse(sdk, oauthParams, res, urls).catch(err => {\n      if (!isInteractionRequiredError(err)) {\n        sdk.transactionManager.clear({\n          state\n        });\n      }\n\n      throw err;\n    }).then(res => {\n      sdk.transactionManager.clear({\n        state\n      });\n      return res;\n    });\n  });\n  return _parseFromUrl.apply(this, arguments);\n}\n\nexport { cleanOAuthResponseFromUrl, getResponseMode, parseFromUrl, parseOAuthResponseFromUrl }; //# sourceMappingURL=parseFromUrl.js.map","map":null,"metadata":{},"sourceType":"module"}