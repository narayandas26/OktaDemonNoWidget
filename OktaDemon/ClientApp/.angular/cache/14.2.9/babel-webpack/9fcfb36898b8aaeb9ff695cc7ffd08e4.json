{"ast":null,"code":"import _asyncToGenerator from \"C:/Users/Narean/source/repos/OktaDemon/OktaDemon/ClientApp/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\n\n/*!\n * Copyright (c) 2015-present, Okta, Inc. and/or its affiliates. All rights reserved.\n * The Okta software accompanied by this notice is provided pursuant to the Apache License, Version 2.0 (the \"License.\")\n *\n * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0.\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * \n * See the License for the specific language governing permissions and limitations under the License.\n */\nimport { getWellKnown } from '../endpoints/well-known.js';\nimport AuthSdkError from '../../errors/AuthSdkError.js';\nimport { getDefaultTokenParams } from './defaultTokenParams.js';\nimport { DEFAULT_CODE_CHALLENGE_METHOD } from '../../constants.js';\nimport PKCE from './pkce.js';\n\nfunction assertPKCESupport(sdk) {\n  if (!sdk.features.isPKCESupported()) {\n    var errorMessage = 'PKCE requires a modern browser with encryption support running in a secure context.';\n\n    if (!sdk.features.isHTTPS()) {\n      errorMessage += '\\nThe current page is not being served with HTTPS protocol. PKCE requires secure HTTPS protocol.';\n    }\n\n    if (!sdk.features.hasTextEncoder()) {\n      errorMessage += '\\n\"TextEncoder\" is not defined. To use PKCE, you may need to include a polyfill/shim for this browser.';\n    }\n\n    throw new AuthSdkError(errorMessage);\n  }\n}\n\nfunction validateCodeChallengeMethod(_x, _x2) {\n  return _validateCodeChallengeMethod.apply(this, arguments);\n}\n\nfunction _validateCodeChallengeMethod() {\n  _validateCodeChallengeMethod = _asyncToGenerator(function* (sdk, codeChallengeMethod) {\n    codeChallengeMethod = codeChallengeMethod || sdk.options.codeChallengeMethod || DEFAULT_CODE_CHALLENGE_METHOD;\n    const wellKnownResponse = yield getWellKnown(sdk);\n    var methods = wellKnownResponse['code_challenge_methods_supported'] || [];\n\n    if (methods.indexOf(codeChallengeMethod) === -1) {\n      throw new AuthSdkError('Invalid code_challenge_method');\n    }\n\n    return codeChallengeMethod;\n  });\n  return _validateCodeChallengeMethod.apply(this, arguments);\n}\n\nfunction preparePKCE(_x3, _x4) {\n  return _preparePKCE.apply(this, arguments);\n}\n\nfunction _preparePKCE() {\n  _preparePKCE = _asyncToGenerator(function* (sdk, tokenParams) {\n    let {\n      codeVerifier,\n      codeChallenge,\n      codeChallengeMethod\n    } = tokenParams;\n    codeChallenge = codeChallenge || sdk.options.codeChallenge;\n\n    if (!codeChallenge) {\n      assertPKCESupport(sdk);\n      codeVerifier = codeVerifier || PKCE.generateVerifier();\n      codeChallenge = yield PKCE.computeChallenge(codeVerifier);\n    }\n\n    codeChallengeMethod = yield validateCodeChallengeMethod(sdk, codeChallengeMethod);\n    tokenParams = Object.assign(Object.assign({}, tokenParams), {\n      responseType: 'code',\n      codeVerifier,\n      codeChallenge,\n      codeChallengeMethod\n    });\n    return tokenParams;\n  });\n  return _preparePKCE.apply(this, arguments);\n}\n\nfunction prepareTokenParams(_x5) {\n  return _prepareTokenParams.apply(this, arguments);\n}\n\nfunction _prepareTokenParams() {\n  _prepareTokenParams = _asyncToGenerator(function* (sdk, tokenParams = {}) {\n    const defaults = getDefaultTokenParams(sdk);\n    tokenParams = Object.assign(Object.assign({}, defaults), tokenParams);\n\n    if (tokenParams.pkce === false) {\n      return tokenParams;\n    }\n\n    return preparePKCE(sdk, tokenParams);\n  });\n  return _prepareTokenParams.apply(this, arguments);\n}\n\nexport { assertPKCESupport, preparePKCE, prepareTokenParams, validateCodeChallengeMethod }; //# sourceMappingURL=prepareTokenParams.js.map","map":null,"metadata":{},"sourceType":"module"}