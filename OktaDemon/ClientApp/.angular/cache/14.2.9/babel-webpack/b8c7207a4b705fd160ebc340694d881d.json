{"ast":null,"code":"import _asyncToGenerator from \"C:/Users/Narean/source/repos/OktaDemon/OktaDemon/ClientApp/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\n\n/*!\n * Copyright (c) 2015-present, Okta, Inc. and/or its affiliates. All rights reserved.\n * The Okta software accompanied by this notice is provided pursuant to the Apache License, Version 2.0 (the \"License.\")\n *\n * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0.\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * \n * See the License for the specific language governing permissions and limitations under the License.\n */\nimport PCancelable from 'p-cancelable';\nimport AuthSdkError from '../errors/AuthSdkError.js';\nimport { getConsole } from '../util/console.js';\nimport { PromiseQueue } from '../util/PromiseQueue.js';\nimport 'tiny-emitter';\nimport 'js-cookie';\nimport 'cross-fetch';\nimport { EVENT_ADDED, EVENT_REMOVED } from '../oidc/types/TokenManager.js';\nconst INITIAL_AUTH_STATE = null;\nconst DEFAULT_PENDING = {\n  updateAuthStatePromise: null,\n  canceledTimes: 0\n};\nconst EVENT_AUTH_STATE_CHANGE = 'authStateChange';\nconst MAX_PROMISE_CANCEL_TIMES = 10;\n\nconst isSameAuthState = (prevState, state) => {\n  if (!prevState) {\n    return false;\n  }\n\n  return prevState.isAuthenticated === state.isAuthenticated && JSON.stringify(prevState.idToken) === JSON.stringify(state.idToken) && JSON.stringify(prevState.accessToken) === JSON.stringify(state.accessToken) && prevState.error === state.error;\n};\n\nclass AuthStateManager {\n  constructor(sdk) {\n    if (!sdk.emitter) {\n      throw new AuthSdkError('Emitter should be initialized before AuthStateManager');\n    }\n\n    this._sdk = sdk;\n    this._pending = Object.assign({}, DEFAULT_PENDING);\n    this._authState = INITIAL_AUTH_STATE;\n    this._logOptions = {};\n    this._prevAuthState = null;\n    this._transformQueue = new PromiseQueue({\n      quiet: true\n    });\n    sdk.tokenManager.on(EVENT_ADDED, (key, token) => {\n      this._setLogOptions({\n        event: EVENT_ADDED,\n        key,\n        token\n      });\n\n      this.updateAuthState();\n    });\n    sdk.tokenManager.on(EVENT_REMOVED, (key, token) => {\n      this._setLogOptions({\n        event: EVENT_REMOVED,\n        key,\n        token\n      });\n\n      this.updateAuthState();\n    });\n  }\n\n  _setLogOptions(options) {\n    this._logOptions = options;\n  }\n\n  getAuthState() {\n    return this._authState;\n  }\n\n  getPreviousAuthState() {\n    return this._prevAuthState;\n  }\n\n  updateAuthState() {\n    var _this = this;\n\n    return _asyncToGenerator(function* () {\n      const {\n        transformAuthState,\n        devMode\n      } = _this._sdk.options;\n\n      const log = status => {\n        const {\n          event,\n          key,\n          token\n        } = _this._logOptions;\n        getConsole().group(`OKTA-AUTH-JS:updateAuthState: Event:${event} Status:${status}`);\n        getConsole().log(key, token);\n        getConsole().log('Current authState', _this._authState);\n        getConsole().groupEnd();\n        _this._logOptions = {};\n      };\n\n      const emitAuthStateChange = authState => {\n        if (isSameAuthState(_this._authState, authState)) {\n          devMode && log('unchanged');\n          return;\n        }\n\n        _this._prevAuthState = _this._authState;\n        _this._authState = authState;\n\n        _this._sdk.emitter.emit(EVENT_AUTH_STATE_CHANGE, Object.assign({}, authState));\n\n        devMode && log('emitted');\n      };\n\n      const finalPromise = origPromise => {\n        return _this._pending.updateAuthStatePromise.then(() => {\n          const curPromise = _this._pending.updateAuthStatePromise;\n\n          if (curPromise && curPromise !== origPromise) {\n            return finalPromise(curPromise);\n          }\n\n          return _this.getAuthState();\n        });\n      };\n\n      if (_this._pending.updateAuthStatePromise) {\n        if (_this._pending.canceledTimes >= MAX_PROMISE_CANCEL_TIMES) {\n          devMode && log('terminated');\n          return finalPromise(_this._pending.updateAuthStatePromise);\n        } else {\n          _this._pending.updateAuthStatePromise.cancel();\n        }\n      }\n\n      const cancelablePromise = new PCancelable((resolve, _, onCancel) => {\n        onCancel.shouldReject = false;\n        onCancel(() => {\n          _this._pending.updateAuthStatePromise = null;\n          _this._pending.canceledTimes = _this._pending.canceledTimes + 1;\n          devMode && log('canceled');\n        });\n\n        const emitAndResolve = authState => {\n          if (cancelablePromise.isCanceled) {\n            resolve();\n            return;\n          }\n\n          emitAuthStateChange(authState);\n          resolve();\n          _this._pending = Object.assign({}, DEFAULT_PENDING);\n        };\n\n        _this._sdk.isAuthenticated().then(() => {\n          if (cancelablePromise.isCanceled) {\n            resolve();\n            return;\n          }\n\n          const {\n            accessToken,\n            idToken,\n            refreshToken\n          } = _this._sdk.tokenManager.getTokensSync();\n\n          const authState = {\n            accessToken,\n            idToken,\n            refreshToken,\n            isAuthenticated: !!(accessToken && idToken)\n          };\n          const promise = transformAuthState ? _this._transformQueue.push(transformAuthState, null, _this._sdk, authState) : Promise.resolve(authState);\n          promise.then(authState => emitAndResolve(authState)).catch(error => emitAndResolve({\n            accessToken,\n            idToken,\n            refreshToken,\n            isAuthenticated: false,\n            error\n          }));\n        });\n      });\n      _this._pending.updateAuthStatePromise = cancelablePromise;\n      return finalPromise(cancelablePromise);\n    })();\n  }\n\n  subscribe(handler) {\n    this._sdk.emitter.on(EVENT_AUTH_STATE_CHANGE, handler);\n  }\n\n  unsubscribe(handler) {\n    this._sdk.emitter.off(EVENT_AUTH_STATE_CHANGE, handler);\n  }\n\n}\n\nexport { AuthStateManager, INITIAL_AUTH_STATE }; //# sourceMappingURL=AuthStateManager.js.map","map":null,"metadata":{},"sourceType":"module"}